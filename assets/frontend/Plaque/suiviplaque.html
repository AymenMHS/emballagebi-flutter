<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../style-index.css">
  <title>EmballageBI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap"
    rel="stylesheet">
  <script src="../runtime_config.js"></script>
  <script>
    // force explicit API_BASE (tu as déjà ça)
    window.API_BASE = "https://emballage-b-impression.dz/emballage_bi";
    // Sauvegarde immédiate de la vraie fetch native AVANT que d'autres scripts puissent l'écraser
    if (!window.__API_NATIVE_FETCH_BACKUP) {
      try {
        window.__API_NATIVE_FETCH_BACKUP = window.fetch.bind(window);
        console.log('runtime_config forced:', window.API_BASE, ' — native fetch backed up.');
      } catch (e) {
        console.warn('Impossible de binder fetch native:', e);
      }
    }
  </script>
  <!-- api wrapper depends on window.API_BASE -->
  <script src="../api.js"></script>
  <!-- verify-connected uses api/buildApiUrl & binds logout -->
  <script src="../verify-connected.js"></script>
  <script src="../notification.js"></script>
  <script src="../ui-shell.js"></script>
  <link rel="stylesheet" href="../notif.css">
  <link rel="stylesheet" href="../responsive.css">
</head>
<style>
  html,
  body {
    overflow: hidden !important;
    max-height: 100vh !important;
  }

  .index-start {
    background: linear-gradient(180deg, rgb(0, 43, 83) 0%, rgb(0, 0, 0) 100%);
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .header {
    animation: fadeInDown;
    animation-duration: 0.5s;
  }

  .index-container {
    animation: fadeInUp;
    animation-duration: 0.5s;
  }


  /* --- Nouvelle apparence pour .select-plaque --- */
  .index-container .select-plaque {
    width: 70%;
    max-height: 80vh !important;
    margin: 18px auto 40px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    font-family: "Nunito", sans-serif;
  }

  /* Titre */
  .index-container .select-plaque h2 {
    margin: 0;
    font-size: 34px;
    font-weight: 600;
    color: #ffffff;
    text-align: center;
    letter-spacing: -0.5px;
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
  }

  /* Card contenant tout */
  .index-container .select-plaque .container-select-plaque {
    display: grid;
    max-height: 85vh !important;
    grid-template-columns: 1fr;
    gap: 12px;
    background: linear-gradient(180deg, #23366a 0%, #1b2a54 100%);
    border-radius: 14px;
    padding: 18px;
    box-shadow: 0 12px 30px rgba(189, 191, 196, 0.20);
    align-items: start;
  }

  /* Ligne header recherche : selects + big search + scan */
  .em-search-row {
    display: grid;
    grid-template-columns: 1fr 1.6fr auto;
    gap: 12px;
    align-items: center;
  }

  /* Left: selects stacked */
  .em-selects {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
  }

  .em-select-wrap {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 160px;
  }

  .em-select-wrap span {
    color: #494949;
    font-size: 13px;
  }

  .em-select-wrap select {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(180deg, #fff, #f6f8ff);
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(10, 20, 40, 0.08);
    font-size: 14px;
    min-width: 160px;
    box-shadow: 0 4px 14px rgba(3, 10, 30, 0.06);
    width: 300px;
  }

  /* Middle: large search input for plaque number (le script utilise le même input[type=number]) */
  .em-code-search {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 5px;
    border-radius: 12px;
    width: 200px;
    flex-direction: column;
    position: relative;
    flex: 1;
  }

  .em-code-search span {
    font-size: 13px;
  }

  .em-code-search input {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(180deg, #fff, #f6f8ff);
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(10, 20, 40, 0.08);
    font-size: 14px;
    min-width: 160px;
    box-shadow: 0 4px 14px rgba(3, 10, 30, 0.06);
    width: 300px;
    margin: 0;
  }

  .em-code-search input::placeholder {
    font-size: 13px;
  }

  .em-code-search .icon-search {
    position: absolute;
    left: 10px;
    top: 35px;
    width: 18px;
    height: 18px;
    opacity: 0.9;
    filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.15));
  }

  .em-code-search input[type="number"] {
    width: 100%;
    padding: 12px 14px 12px 36px;
    /* espace pour icône */
    border-radius: 10px;
    border: none;
    outline: none;
    font-size: 18px;
    background: linear-gradient(180deg, #ffffff, #f7fbff);
    box-shadow: inset 0 1px 0 rgba(10, 20, 40, 0.02);
    color: #0b1220;
  }

  /* Right: scan button */
  .em-scan-btn {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .em-scan-btn button {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 25px 20px;
    border-radius: 10px;
    background: linear-gradient(45deg, #1f73da, #014687);
    color: white;
    border: none;
    font-weight: 600;
    cursor: pointer;
  }

  .em-scan-btn button:hover {
    opacity: 0.8;
    transform: translate(0px, -1px);
    transition: 0.3s ease;
  }

  .em-scan-btn button:active {
    transform: translate(0px, 2px);
  }

  .em-scan-btn button img {
    width: 20px;
    height: 20px;
    filter: invert(1);
  }

  .em-scan-btn #searchBTN {
    background: linear-gradient(45deg, #123e73, #003669);
  }

  .em-quick {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end;
  }

  .em-chip {
    background: rgba(164, 65, 65, 0.08);
    color: #eaf0ff;
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 13px;
    cursor: pointer;
    border: 1px solid rgba(255, 255, 255, 0.03);
  }

  .em-chip:hover {
    transform: translateY(-2px);
    transition: 150ms ease;
  }

  .index-container .select-plaque .plaques {
    max-width: 100% !important;
    max-height: 40vh !important;
    background-color: white;
    border-radius: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center !important;
    margin-bottom: 10px;
    overflow-x: hidden;
  }

  /* Plaque card modern */
  .index-container .select-plaque .plaques .plaque {
    width: calc(100% - 20px);
    margin-left: 10px;
    margin-right: 10px;
    height: 150px;
    background-color: #d6d4d4;
    border-radius: 10px;
    margin-top: 5px;
    margin-bottom: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .index-container .select-plaque .plaques .plaque .image-plaque {
    width: 140px;
    height: 140px;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: white;
    border-radius: 10px;
    margin-left: 5px;
  }

  .index-container .select-plaque .plaques .plaque .image-plaque img {
    width: 100px;
    height: 100px;
  }

  .index-container .select-plaque .plaques .plaque .infos-plaque {
    width: calc(100% - 150px);
    height: 150px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }


  .conception-infos-plaque {
    display: flex;
    width: 40%;
    height: 150px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
  }

  .conception-infos-plaque h1 {
    width: calc(100% - 20px);
    height: 30px;
    font-size: 20px;
    font-family: "Nunito", sans-serif;
    font-weight: bold;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    margin-left: 20px;
    margin-top: 20px;
  }

  .conception-infos-plaque p {
    width: calc(100% - 20px);
    height: 30px;
    font-size: 12px;
    font-family: "Nunito", sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    margin-left: 20px;
  }

  .conception-infos-plaque p b {
    margin-left: 5px;
    margin-right: 5px;
  }

  .details-infos-plaque {
    width: 40%;
    height: 150px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }

  .details-infos-plaque p {
    width: 100%;
    height: 30px;
    font-size: 16px;
    font-family: "Nunito", sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: flex-start;
    align-items: center;
  }

  .details-infos-plaque p input {
    width: 40px;
    height: 30px;
    border-radius: 5px;
    border: none;
    margin-left: 5px;
  }

  .details-infos-plaque p b {
    margin-left: 5px;
  }

  .status-infos-plaque {
    width: 20%;
    height: 150px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .status-infos-plaque p {
    width: 100%;
    height: 75px;
    font-size: 18px;
    font-family: "Nunito", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .status-infos-plaque p img {
    width: 10px;
    height: 10px;
    margin-right: 5px;
  }


  .btns-infos-plaque {
    width: calc(40% - 140px);
    height: 150px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }

  .btns-infos-plaque button {
    width: 90%;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgb(115, 0, 0);
    color: white;
    font-family: "Nunito", sans-serif;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }

  .btns-infos-plaque button:hover {
    opacity: 0.6;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transform: translateY(-2px);
    transition: 0.3s ease;
  }

  .btns-infos-plaque button:active {
    transform: translateY(2px);
    box-shadow: none;
  }

  .btns-infos-plaque button img {
    width: 20px;
    height: 20px;
    filter: invert(100%);
  }

  .btns-infos-plaque .input-infos-plaque {
    width: 90%;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 5px;
  }

  .btns-infos-plaque .input-infos-plaque input {
    width: calc(100% - 35px);
    height: 28px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 5px;
    border: none;
    margin-right: 5px;
    padding-left: 5px;
  }

  .btns-infos-plaque .input-infos-plaque button {
    width: 30px;
    height: 30px;
  }

  .btns-infos-plaque .input-infos-plaque button img {
    filter: invert(0%);
  }

  .input-infos-plaque input {
    flex: 1;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid rgba(10, 20, 40, 0.06);
  }

  .sr-only {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0 0 0 0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }

  /* ---------------------------
   EnhancedMultiSelect styles
   (moved here from JS)
   classPrefix = "em-"
   itemEstimateHeight = 44
   maxVisibleItems = 8
   --------------------------- */

  :root {
    --em-accent: #0b6efd;
    --em-bg: #ffffff;
    --em-ghost: rgba(0, 0, 0, 0.06);
    --em-muted: rgba(0, 0, 0, 0.45);
    --em-match: #fff6c8;
    --em-border: rgba(16, 24, 40, 0.08);
    --em-radius: 10px;
  }

  .em-container {
    display: inline-block;
    vertical-align: middle;
    font-family: inherit;
    width: 200px;
  }

  .em-trigger {
    min-width: 180px;
    min-height: 44px;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    border-radius: var(--em-radius);
    border: 1px solid var(--em-border);
    background: linear-gradient(180deg, #ffffff, #fbfdff);
    box-shadow: 0 2px 6px rgba(16, 24, 40, 0.04);
    cursor: pointer;
    box-sizing: border-box;
    transition: box-shadow .12s, transform .06s;
  }

  .em-trigger:hover {
    box-shadow: 0 6px 18px rgba(11, 110, 253, 0.08);
    transform: translateY(-1px);
  }

  .em-tags {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
    max-width: 420px;
    color: black !important;
  }

  .em-placeholder {
    color: var(--em-muted);
    font-size: 12px !important;
  }

  .em-tag {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 8px;
    border-radius: 999px;
    background: var(--em-ghost);
    font-size: 13px;
    color: #0f1724;
  }

  .em-tag .remove {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: transparent;
    font-size: 12px;
    color: rgba(0, 0, 0, 0.9);
    cursor: pointer;
    border: 1px solid transparent;
    transition: background .12s, color .12s;
  }

  .em-tag .remove:hover {
    background: rgba(0, 0, 0, 0.06);
    color: #000;
  }

  .em-caret {
    margin-left: auto;
    font-size: 12px;
    color: var(--em-muted);
    transition: transform .18s ease;
  }

  .em-caret.open {
    transform: rotate(180deg);
    color: var(--em-accent);
  }

  .em-dropdown {
    position: absolute;
    top: 55vh !important;
    z-index: 2147483000;
    max-height: 300px !important;
    min-width: 260px;
    max-width: 96vw;
    background: var(--em-bg);
    border: 1px solid var(--em-border);
    border-radius: 12px;
    box-shadow: 0 18px 40px rgba(2, 6, 23, 0.12);
    padding: 10px;
    box-sizing: border-box;
    animation: em-fade .12s ease;
  }

  @keyframes em-fade {
    from {
      opacity: 0;
      transform: translateY(-4px) scale(.995);
    }

    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .em-dropdown.mobile {
    left: 8px !important;
    right: 8px !important;
    max-height: 300px !important;
    width: auto !important;
    max-width: calc(100% - 16px) !important;
    border-radius: 10px !important;
  }

  .em-search {
    width: 100%;
    padding: 10px 12px;
    border-radius: 8px;
    border: 1px solid rgba(2, 6, 23, 0.06);
    box-sizing: border-box;
    outline: none;
    font-size: 14px;
  }

  .em-search:focus {
    box-shadow: 0 6px 24px rgba(11, 110, 253, 0.06);
    border-color: rgba(11, 110, 253, 0.28);
  }

  .em-actions {
    display: flex;
    gap: 8px;
    margin: 8px 0;
  }

  .em-btn {
    padding: 8px 10px;
    border-radius: 8px;
    background: transparent;
    border: 1px solid rgba(2, 6, 23, 0.06);
    cursor: pointer;
    font-size: 13px;
    color: #0f1724;
  }

  .em-btn:hover {
    background: rgba(11, 110, 253, 0.06);
    border-color: rgba(11, 110, 253, 0.12);
    color: var(--em-accent);
  }

  .em-list {
    overflow: auto;
    max-height: 200px !important;
    border-radius: 8px;
    border-top: 1px solid rgba(2, 6, 23, 0.02);
    border-bottom: 1px solid rgba(2, 6, 23, 0.02);
  }

  .em-list::-webkit-scrollbar {
    height: 8px;
    width: 8px;
  }

  .em-list::-webkit-scrollbar-thumb {
    background: rgba(2, 6, 23, 0.12);
    border-radius: 8px;
  }

  .em-row {
    display: flex;
    gap: 10px;
    align-items: center;
    padding: 10px;
    min-height: 44px;
    box-sizing: border-box;
    cursor: pointer;
    transition: background .08s;
  }

  .em-row:hover {
    background: rgba(11, 110, 253, 0.04);
  }

  .em-row[aria-selected="true"] {
    background: linear-gradient(90deg, rgba(11, 110, 253, 0.06), rgba(11, 110, 253, 0.02));
    border-radius: 6px;
  }

  .em-row input[type="checkbox"] {
    accent-color: var(--em-accent);
    width: 18px;
    height: 18px;
  }

  .em-icon {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    object-fit: cover;
    display: block;
    flex-shrink: 0;
  }

  .em-row .label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 14px;
    color: #0f1724;
  }

  .em-match {
    background: var(--em-match);
    padding: 0 4px;
    border-radius: 4px;
    font-weight: 700;
    color: #2b2b2b;
  }

  .em-loader {
    padding: 12px;
    text-align: center;
    color: var(--em-muted);
  }

  .em-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    font-size: 13px;
    color: var(--em-muted);
  }

  @media (max-width:600px) {
    .em-trigger {
      min-width: 120px;
      padding: 8px;
    }

    .em-tags {
      max-width: calc(100vw - 110px);
    }
  }

  /* responsive */
  @media (max-width: 900px) {
    .em-search-row {
      grid-template-columns: 1fr;
    }

    .index-container .select-plaque .plaques .plaque {
      grid-template-columns: 90px 1fr;
    }

    .index-container .select-plaque .plaques .plaque .btns-infos-plaque {
      align-items: flex-start;
    }
  }


  .more-Img {
    width: 10%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .more-Img img {
    width: 20px;
    height: 20px;
  }

  /* ========== Espacement lignes, boutons et couleurs mises à jour ========== */

  /* espacement vertical + look rows */
  .plaque-expander .exp-inner {
    padding: 14px;
    box-sizing: border-box;
    font-family: "Nunito", sans-serif;
  }

  .plaque-expander .exp-header,
  .plaque-expander .exp-row {
    display: grid;
    /* 5 colonnes : la dernière colonne (actions) est maintenant plus large */
    grid-template-columns: 1fr 90px 160px 140px minmax(200px, 320px);
    gap: 12px;
    align-items: center;
  }

  .plaque-expander .exp-header {
    font-weight: 700;
    padding: 5px 6px;
    border-bottom: 1px solid rgba(3, 10, 30, 0.04);
  }

  /* plus d'espace entre les lignes : padding + margin + séparation légère */
  .plaque-expander .exp-row {
    border-radius: 8px;
    background: transparent;
    margin-bottom: 8px;
    border-bottom: 1px solid rgba(3, 10, 30, 0.03);
  }

  /* empêcher overflow qui casse la grille */
  .plaque-expander .exp-row>* {
    min-width: 0;
    overflow: hidden;
  }

  /* ===== palette : historique = teal, modifier = plum ===== */
  .plaque-expander .btnHist,
  .plaque-expander .btnEdit {
    display: inline-flex !important;
    align-items: center;
    gap: 8px;
    padding: 8px 14px !important;
    height: 36px;
    font-family: "Nunito", sans-serif;
    font-size: 13px;
    font-weight: 700;
    border-radius: 10px;
    border: none !important;
    cursor: pointer;
    box-shadow: 0 8px 20px rgba(2, 6, 23, 0.08);
    transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    color: #fff !important;
    white-space: nowrap;
  }

  /* Historique : teal (chaud mais frais) */
  .plaque-expander .btnHist {
    background: linear-gradient(180deg, #0f84b2 0%, #0b798f 100%) !important;
    box-shadow: 0 8px 24px rgba(15, 178, 155, 0.12);
  }

  /* Modifier : plum / violet profond */
  .plaque-expander .btnEdit {
    background: linear-gradient(180deg, #3f69b1 0%, #2a4c86 100%) !important;
    box-shadow: 0 8px 24px rgba(123, 63, 177, 0.10);
  }

  /* hover / active */
  .plaque-expander .btnHist:hover,
  .plaque-expander .btnEdit:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 28px rgba(2, 6, 23, 0.14);
    opacity: 0.98;
  }

  .plaque-expander .btnHist:active,
  .plaque-expander .btnEdit:active {
    transform: translateY(0);
  }

  /* focus (accessible) */
  .plaque-expander .btnHist:focus,
  .plaque-expander .btnEdit:focus {
    outline: 3px solid rgba(11, 110, 253, 0.12);
    outline-offset: 3px;
  }

  /* icônes dans les boutons — forcer blanc (utile pour PNG noirs) */
  .plaque-expander .btnHist img,
  .plaque-expander .btnEdit img,
  .btns-infos-plaque button img {
    width: 16px;
    height: 16px;
    filter: invert(0);
  }

  /* ===== input[type=color] : read-only, petit cercle ===== */
  .plaque-expander input[type="color"] {
    width: 28px !important;
    height: 28px !important;
    border-radius: 50% !important;
    padding: 0 !important;
    border: 1px solid rgba(10, 20, 40, 0.06) !important;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
    appearance: none !important;
    -webkit-appearance: none !important;
    cursor: default !important;
    pointer-events: none !important;
    /* rend non modifiable */
    vertical-align: middle;
  }

  /* remove default focus ring visuals (we keep aria-readonly but not focusable) */
  .plaque-expander input[type="color"]:focus {
    outline: none !important;
  }

  /* responsive tweaks */
  @media (max-width: 900px) {

    .plaque-expander .exp-header,
    .plaque-expander .exp-row {
      grid-template-columns: 1fr 70px 120px 110px minmax(80px, 160px);
      gap: 8px;
    }

    .plaque-expander .btnHist,
    .plaque-expander .btnEdit {
      min-width: 82px;
      height: 34px;
      font-size: 12px;
      gap: 6px;
    }
  }

  .btns-hist-edit {
    padding-left: 10px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* ========== Agrandir la colonne "actions" (Historique / Modifier) ========== */
  /* Remplace les grid-template-columns précédents par ça pour donner plus d'espace à la colonne actions */
  .plaque-expander .exp-header,
  .plaque-expander .exp-row {
    display: grid;
    /* 5 colonnes : la dernière colonne (actions) est maintenant plus large */
    grid-template-columns: 1fr 90px 160px 140px minmax(200px, 320px);
    gap: 12px;
    align-items: center;
  }

  /* s'assurer que la cellule actions possède un espace minimal */
  .plaque-expander .exp-row .btns-hist-edit {
    min-width: 200px;
    /* garantit largeur minimale pour le conteneur d'actions */
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    padding-left: 6px;
  }

  /* s'assurer que les boutons eux-mêmes ne s'écrasent pas */
  .plaque-expander .btnHist,
  .plaque-expander .btnEdit {
    min-width: 110px;
    /* largeur minimale par bouton */
    max-width: 100%;
    /* sécurise le comportement sur petits écrans */
    white-space: nowrap;
    box-sizing: border-box;
  }

  /* si nécessaire, on force le wrapping propre des éléments internes */
  .plaque-expander .exp-row>* {
    min-width: 0;
    overflow: hidden;
  }

  /* Responsive : réduire la colonne actions sur petits écrans mais garder lisibilité */
  @media (max-width: 900px) {

    .plaque-expander .exp-header,
    .plaque-expander .exp-row {
      grid-template-columns: 1fr 70px 120px 110px minmax(120px, 220px);
      gap: 8px;
    }

    .plaque-expander .exp-row .btns-hist-edit {
      min-width: 120px;
    }

    .plaque-expander .btnHist,
    .plaque-expander .btnEdit {
      min-width: 82px;
      height: 34px;
      font-size: 12px;
      gap: 6px;
    }
  }

  .btns-edit {
    height: 100px !important;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0;
    padding: 0;
    padding-right: 10px;
  }

  /* ---------- Modal statut : overlay + panneau ---------- */
  .status-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(6, 12, 24, 0.48);
    z-index: 2147483001;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
  }

  .status-modal {
    width: min(760px, 96vw);
    max-width: 760px;
    background: linear-gradient(180deg, #ffffff, #fbfdff);
    border-radius: 12px;
    box-shadow: 0 24px 60px rgba(2, 6, 23, 0.28);
    padding: 18px;
    box-sizing: border-box;
    font-family: "Nunito", sans-serif;
    color: #0f1724;
    outline: none;
  }

  .status-modal header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
  }

  .status-modal h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 800;
  }

  .status-modal p.desc {
    margin: 0;
    font-size: 13px;
    color: #51607a;
  }

  /* options grid */
  .status-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    gap: 10px;
    margin: 14px 0 18px;
  }

  .status-option {
    display: flex;
    gap: 10px;
    align-items: center;
    padding: 10px;
    border-radius: 10px;
    border: 1px solid rgba(3, 10, 30, 0.06);
    cursor: pointer;
    transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease, background .12s ease;
    user-select: none;
  }

  .status-option:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 30px rgba(2, 6, 23, 0.06);
  }

  .status-option .status-swatch {
    width: 42px;
    height: 42px;
    border-radius: 8px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-weight: 800;
    box-shadow: 0 6px 18px rgba(2, 6, 23, 0.06);
  }

  .status-option .status-meta {
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow: hidden;
  }

  .status-option .status-title {
    font-weight: 700;
    font-size: 14px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .status-option .status-sub {
    font-size: 12px;
    color: #51607a;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* selected */
  .status-option[aria-checked="true"] {
    border-color: rgba(11, 110, 253, 0.16);
    box-shadow: 0 12px 30px rgba(11, 110, 253, 0.06);
    background: linear-gradient(180deg, rgba(11, 110, 253, 0.03), rgba(11, 110, 253, 0.01));
  }

  .status-option .checkmark {
    margin-left: auto;
    width: 26px;
    height: 26px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 800;
    background: rgba(0, 0, 0, 0.06);
  }

  /* footer buttons */
  .status-modal .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 6px;
  }

  .status-modal .btn {
    padding: 8px 14px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-weight: 700;
    box-shadow: 0 8px 20px rgba(2, 6, 23, 0.06);
  }

  .status-modal .btn-secondary {
    background: transparent;
    border: 1px solid rgba(3, 10, 30, 0.06);
    color: #0f1724;
  }

  .status-modal .btn-primary {
    background: linear-gradient(180deg, #0b84ff, #0a6fe6);
    color: #fff;
    box-shadow: 0 12px 32px rgba(11, 110, 253, 0.12);
  }

  /* small responsive tweaks */
  @media (max-width:420px) {
    .status-option {
      padding: 8px;
      gap: 8px;
    }

    .status-option .status-swatch {
      width: 36px;
      height: 36px;
    }
  }

  /* Quick-actions (UI ergonomique) */
  .status-quickactions {
    display: flex;
    gap: 10px;
    margin: 6px 0 12px;
    align-items: center;
    flex-wrap: wrap;
  }

  .qa-btn {
    padding: 10px 14px;
    border-radius: 10px;
    border: 1px solid rgba(3, 10, 30, 0.06);
    min-width: 170px;
    display: flex;
    gap: 10px;
    align-items: center;
    cursor: pointer;
    font-weight: 800;
    box-shadow: 0 10px 26px rgba(2, 6, 23, 0.04);
    transition: transform .12s, box-shadow .12s, background .12s;
    background: linear-gradient(180deg, #fff, #fbfdff);
  }

  .qa-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 16px 36px rgba(2, 6, 23, 0.06);
  }

  .qa-btn .qa-swatch {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-weight: 900;
  }

  .qa-btn--danger {
    border-color: rgba(239, 68, 68, 0.14);
  }

  .qa-btn--success {
    border-color: rgba(16, 185, 129, 0.12);
  }

  .qa-btn--warning {
    border-color: rgba(245, 158, 11, 0.12);
  }

  .qa-btn[aria-pressed="true"] {
    background: linear-gradient(180deg, rgba(11, 110, 253, 0.04), rgba(11, 110, 253, 0.02));
    border-color: rgba(11, 110, 253, 0.12);
    box-shadow: 0 16px 40px rgba(11, 110, 253, 0.06);
  }

  /* comment area */
  .status-comment {
    margin-top: 8px;
    display: flex;
    gap: 10px;
    align-items: flex-start;
  }

  .status-comment textarea {
    width: 100%;
    min-height: 76px;
    border-radius: 8px;
    padding: 10px;
    border: 1px solid rgba(3, 10, 30, 0.06);
    box-sizing: border-box;
    font-family: inherit;
    resize: vertical;
    font-size: 13px;
    color: #0f1724;
  }

  /* severity toggle (only for defaillance option) */
  .severity-toggle {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-left: auto;
  }

  .severity-chip {
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(3, 10, 30, 0.06);
    font-weight: 700;
    cursor: pointer;
  }

  .severity-chip[aria-pressed="true"] {
    background: rgba(239, 68, 68, 0.08);
    border-color: rgba(239, 68, 68, 0.16);
  }



  .suivi-status-group {
    display: inline-flex;
    gap: 0;
    align-items: center;
  }

  .btn {
    font: inherit;
    background-color: #f0f0f0;
    border: 0;
    color: #242424;
    font-size: 1.15rem;
    padding: 0.375em 1em;
    text-shadow: 0 0.0625em 0 #fff;
    box-shadow:
      inset 0 0.0625em 0 0 #f4f4f4,
      0 0.0625em 0 0 #efefef,
      0 0.125em 0 0 #ececec,
      0 0.25em 0 0 #e0e0e0,
      0 0.3125em 0 0 #dedede,
      0 0.375em 0 0 #dcdcdc,
      0 0.425em 0 0 #cacaca,
      0 0.425em 0.5em 0 #cecece;
    transition: 0.23s ease;
    cursor: pointer;
    font-weight: bold;
    margin: -1px;
    line-height: 1;
  }

  .middle {
    border-radius: 0px;
  }

  .right {
    border-top-right-radius: 0.5em;
    border-bottom-right-radius: 0.5em;
  }

  .left {
    border-top-left-radius: 0.5em;
    border-bottom-left-radius: 0.5em;
  }

  .btn:active {
    transform: translateY(0.225em);
    box-shadow:
      inset 0 0.03em 0 0 #f4f4f4,
      0 0.03em 0 0 #efefef,
      0 0.0625em 0 0 #ececec,
      0 0.125em 0 0 #e0e0e0,
      0 0.125em 0 0 #dedede,
      0 0.2em 0 0 #dcdcdc,
      0 0.225em 0 0 #cacaca,
      0 0.225em 0.375em 0 #cecece;
    letter-spacing: 0.1em;
    color: skyblue;
  }

  .btn:focus {
    color: skyblue;
    outline: 3px solid rgba(59, 130, 246, 0.12);
  }

  /* hint variants */
  .btn.stock {
    background: linear-gradient(#f7fffb, #effff4);
    border: 1px solid rgba(16, 185, 129, 0.10);
    color: #065f46;
  }

  .btn.impression {
    background: linear-gradient(#fff9f6, #fff3ea);
    border: 1px solid rgba(245, 158, 11, 0.10);
    color: #92400e;
  }

  .btn.indispo {
    background: linear-gradient(#fff8fb, #fff2f7);
    border: 1px solid rgba(239, 68, 68, 0.10);
    color: #7f1d1d;
  }

  /* ACTIVE state: full color, white text */
  .btn.active {
    color: #fff;
    text-shadow: none;
    box-shadow: none;
  }

  .btn.stock.active {
    background: linear-gradient(#10b981, #059669);
    border-color: rgba(6, 95, 70, 0.12);
  }

  .btn.impression.active {
    background: linear-gradient(#f59e0b, #d97706);
    border-color: rgba(194, 65, 12, 0.14);
  }

  .btn.indispo.active {
    background: linear-gradient(#ef4444, #b91c1c);
    border-color: rgba(139, 23, 23, 0.14);
  }

  /* disabled state */
  .btn[disabled] {
    opacity: 0.6;
    cursor: wait;
  }

  /* keep actions layout */
  .suivi-plaque__actions {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-left: 12px;
  }




  .index-start .logo {
    width: 30% !important;
  }

  .index-start .logo img {
    width: 60px !important;
    height: 60px !important;
    display: block;
    transition: transform 0.25s ease;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    /* propre sur mobile */
  }

  .index-start .logo img:hover,
  .index-start .logo img:focus {
    transform: scale(1.05);
    /* Agrandit de 5% */
  }

  .index-start .logo img:active {
    transform: scale(1.00);
  }

  .index-start .logo .title-logo h1 {
    font-size: 30px !important;
    width: 300px !important;
    top: 10px !important;
  }

  .index-start .logo .title-logo p {
    font-size: 18px !important;
    color: rgb(255, 36, 36);
    margin: 0;
    padding: 0;
    position: absolute;
    bottom: -3px !important;
    right: -40px !important;
    font-weight: 600;
  }

  .returnBtn img {
    width: 30px;
    height: 30px;
    filter: invert(1);
  }

  .returnBtn img:hover {
    opacity: 0.5;
    cursor: pointer;
    transition: 0.3s ease;
  }

  /* Sidebar & sidenotif mobile-friendly */
  .sidebar,
  .sidenotif {
    position: fixed;
    top: 0;
    height: 100vh;
    z-index: 10001;
    will-change: transform;
    touch-action: pan-y;
    /* on permet le scroll vertical, on gère horizontal manuellement */
    -webkit-overflow-scrolling: touch;
  }

  /* largeur par défaut (desktop) */
  .sidebar {
    left: 0;
    width: 280px;
    transform: translateX(-100%);
    transition: transform 280ms ease;
  }

  .sidenotif {
    right: 0;
    width: 360px;
    transform: translateX(100%);
    transition: transform 280ms ease;
  }

  /* overlay (déjà .filterblack dans ton HTML, on s'assure du style) */
  .filterblack {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    display: none;
    opacity: 0;
    transition: opacity 220ms ease;
    -webkit-tap-highlight-color: transparent;
  }

  /* état ouvert (JS ajoute/retire ces classes) */
  .sidebar.open {
    transform: translateX(0) !important;
  }

  .sidenotif.open {
    transform: translateX(0) !important;
  }

  .filterblack.visible {
    display: block;
    opacity: 0.8;
  }

  /* Ajustements responsive : faire icônes visibles sur téléphone si besoin */
  @media (max-width: 900px) {
    .sidebar {
      width: 78vw;
      max-width: 360px;
    }

    .sidenotif {
      width: 86vw;
      max-width: 420px;
    }

    .header .burger img {
      width: 26px;
      height: 26px;
    }

    /* icône plus petite */
  }

  /* Interaction tactile pendant le drag : disable transition while dragging */
  .sidebar.dragging,
  .sidenotif.dragging {
    transition: none !important;
  }
</style>

<body>
  <div class="filterblack"></div>
  <div class="sidenotif" data-user-id="">
    <div class="notif-header">
      <img src="../img/icon/notifications.png">
      <h2>Notifications</h2>
    </div>
    <div class="notif-elements" style="width: 360px !important;">
      <div class="notif-loading">
        <p>Chargement des notifications...</p>
      </div>
    </div>
  </div>
  <div class="sidebar">
    <img src="../img/icon/menu.png" alt="Close" class="close-sidebar">
    <div class="logo">
      <img src="../img/logoblanc.png" alt="EmballageBI">
      <div class="title-logo">
        <h1>Emballage BI</h1>
        <p>2026</p>
      </div>
    </div>
    <nav class="sidebar-nav">
      <ul>
        <li onclick="window.location.href = '../index.html'" onclick="window.location.href = '../index.html'"><a
            href="#"><img src="../img/icon/home.png" alt="Home"> Tableau de bord</a></li>
        <hr>
        <li onclick="window.location.href = '../Plaque/suiviplaque.html'"><a href="#"><img
              src="../img/icon/papeterie-papiers-empiles.png" alt="Plaques"> Suivi des Plaques</a></li>
        <li onclick="window.location.href = '../Plaque/plaques.html'"><a href="#"><img src="../img/icon/plaques.png"
              alt="Plaques"> Plaques</a></li>
        <hr>
        <li onclick="window.location.href = '../Client/clients.html'"><a href="#"><img src="../img/icon/client.png"
              alt="Client"> Clients</a></li>
        <li onclick="window.location.href = '../Produit/produits.html'"><a href="#"><img
              src="../img/icon/produit - Copie.png" alt="Produit"> Produits</a></li>
        <li onclick="window.location.href = '../Conception/conceptions.html'"><a href="#"><img
              src="../img/icon/personnalisation1.png" alt="Conception"> Conceptions</a></li>
        <hr>
        <li onclick="window.location.href = '../Scan/scan.html'"><a href="#"><img src="../img/icon/qrcode.png" alt="QR">
            Scan
            QR</a></li>
        <li onclick="window.location.href = '../Annonces/annonces.html'"><a href="#"><img src="../img/icon/annonce.png"
              alt="Annonces"> Annonces</a></li>
        <hr>
        <li onclick="window.location.href = '../User/profil.html'"><a href="#"><img src="../img/icon/user.png"
              alt="User">
            Profil</a></li>
        <li onclick="window.location.href = '../Parametres/parametres.html'"><a href="#"><img
              src="../img/icon/parametres.png" alt="Parametres"> Parametres</a></li>

      </ul>
      <a href="#" id="logoutBtn"><img src="../img/icon/se-deconnecter.png" alt="Parametres"> Se deconnecter</a>
    </nav>
  </div>

  <div class="index-start">
    <div class="header" style="justify-content: space-evenly;">
      <div class="user-space" style="display: flex;justify-content: flex-start;width: 15%;">
        <div class="burger" style="margin-left: 30px;">
          <img src="../img/icon/menu.png" alt="Menu">
        </div>
        <div class="returnBtn"
          style="margin-left: 40px;width: 40px;height: 40px;display: flex;justify-content: center;align-items: center;"
          onclick="window.location.href='../index.html'">
          <img src="../img/icon/retourner.png">
        </div>
      </div>
      <div class="logo" onclick="window.location.href='../index.html'">
        <img src="../img/logoblanc.png" alt="EmballageBI" data-red="../img/logorouge.png" tabindex="0" />
      </div>
      <div class="user-space" style="display: flex;justify-content: flex-end;width: 15%;">
        <div class="notif-user">
          <img src="../img/icon/notifications.png" alt="Notifications">
          <span class="notif-count">0</span>
        </div>
        <div class="user-info" onclick="window.location.href='../user/profil.html'">
          <img src="../img/icon/profil.png" alt="User">
        </div>
      </div>
    </div>
    <div class="index-container" style="justify-content: center;">
      <div class="linkpages" style="position: absolute;top: 120px;">
        <a href="../index.html">Tableau de bord</a> > Suivi des plaques
      </div>
      <div class="select-plaque">
        <h2 style="display: flex;justify-content: center; align-items: center;"><img
            src="../img/icon/papeterie-papiers-empiles.png"
            style="width: 35px;height: 35px;filter: invert(1);margin-right: 10px;">Où est ma plaque ?</h2>

        <div class="container-select-plaque">

          <!-- ligne de recherche : selects + champ code + scan -->
          <div class="em-search-row">

            <!-- selects (client & produit) : on garde exactement les <select> pour le JS -->
            <div class="em-selects" aria-hidden="false">
              <div class="em-select-wrap">
                <span style="color: #d9e2ff;">Client</span>
                <!-- select original conservé -->
                <select name="client">
                  <option value="" data-skip="1" selected disabled hidden>-- Sélectionnez un client --</option>
                </select>
              </div>

              <div class="em-select-wrap">
                <span style="color: #d9e2ff;">Produit</span>
                <!-- select original conservé -->
                <select name="produit">
                  <option value="" data-skip="1" selected disabled hidden>-- Sélectionnez un produit --</option>
                </select>
              </div>
            </div>

            <!-- grand champ de recherche par numéro de plaque (on garde l'input[type=number]) -->
            <div class="em-code-search" role="search" aria-label="Recherche plaque par numéro">
              <span style="color: #d9e2ff;">Rechercher N° Plaque</span>
              <svg class="icon-search" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true">
                <path d="M11 4a7 7 0 1 0 0 14 7 7 0 0 0 0-14zm8.5 15.5L17 15" stroke="#0b1220" stroke-width="1.6"
                  stroke-linecap="round" stroke-linejoin="round" />
              </svg>
              <input type="number" placeholder="Rechercher une plaque par N°..." aria-label="Numéro de plaque" />
            </div>

            <!-- bouton scan (conserver la fonction inline si présente), on garde le <button> original mais stylisé -->
            <div class="em-scan-btn">
              <button type="button" onclick="window.location.href='../Scan/scan.html'">
                <img src="../img/icon/qrcode.png" alt="scan">
              </button>
              <button type="button" id="openHistorique">
                <img src="../img/icon/devis.png" alt="historique" style="filter: invert(0);">
              </button>
              <button type="button" id="searchBTN">
                <img src="../img/icon/recherche.png" alt="search" style="filter: invert(0);">
                Chercher
              </button>
            </div>

          </div>

          <!-- zone d'affichage des plaques (le script écrit dedans; on garde la div.plaques) -->
          <div class="plaques" style="display:none;" aria-live="polite" role="dialog"
            aria-label="Résultats des plaques">
            <button type="button" class="plaques__close" aria-label="Fermer les résultats">✕</button>
            <!-- contenu généré par JS -->
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.index-start .logo img').forEach(img => {
        const whiteSrc = img.getAttribute('src');
        const redSrc = img.dataset.red;
        if (!redSrc) return; // si pas de data-red, on ignore

        // Précharger l'image rouge
        const preload = new Image();
        preload.src = redSrc;

        // Fonctions de swap
        const showRed = () => { img.src = redSrc; };
        const showWhite = () => { img.src = whiteSrc; };

        // Mouse / pointer
        img.addEventListener('mouseenter', showRed);
        img.addEventListener('mouseleave', showWhite);

        // Focus/blur pour accessibilité (clavier)
        img.addEventListener('focus', showRed);
        img.addEventListener('blur', showWhite);

        // Touch (mobile) — on utilise pointer events si dispo
        img.addEventListener('pointerdown', showRed);
        img.addEventListener('pointerup', showWhite);
        img.addEventListener('pointercancel', showWhite);

        // Fallback pour anciens navigateurs (touch)
        img.addEventListener('touchstart', showRed, { passive: true });
        img.addEventListener('touchend', showWhite, { passive: true });
      });
    });
  </script>
  <script>
    // Swipe & drag support pour sidebar (gauche) et sidenotif (droite)
    (function () {
      const sidebar = document.querySelector('.sidebar');
      const sidenotifEl = document.querySelector('.sidenotif');
      const filterOverlay = document.querySelector('.filterblack');

      if (!sidebar || !sidenotifEl || !filterOverlay) return;

      let startX = 0, currentX = 0, touching = false;
      let draggingPanel = null; // 'left' or 'right' or null
      const EDGE_THRESHOLD = 28; // px depuis le bord pour initier swipe
      const OPEN_THRESHOLD_RATIO = 0.25; // proportion needed to open

      // helpers
      function showOverlay() { filterOverlay.classList.add('visible'); }
      function hideOverlayIfClosed() {
        if (!sidebar.classList.contains('open') && !sidenotifEl.classList.contains('open')) {
          filterOverlay.classList.remove('visible');
        }
      }

      function setTranslateX(el, x) {
        el.style.transform = `translateX(${x}px)`;
      }

      function resetPanelStyle(el, side) {
        el.style.transform = '';
        el.classList.remove('dragging');
      }

      // Start touch (could be edge swipe or drag on panel)
      function onTouchStart(e) {
        if (e.touches && e.touches.length === 1) {
          startX = e.touches[0].clientX;
          currentX = startX;
          touching = true;
          draggingPanel = null;

          // edge swipe from left -> open sidebar
          if (startX <= EDGE_THRESHOLD && !sidebar.classList.contains('open')) {
            draggingPanel = 'left';
            sidebar.classList.add('dragging');
            showOverlay();
          }
          // edge swipe from right -> open sidenotif
          else if (startX >= (window.innerWidth - EDGE_THRESHOLD) && !sidenotifEl.classList.contains('open')) {
            draggingPanel = 'right';
            sidenotifEl.classList.add('dragging');
            showOverlay();
          } else {
            // if user touches on an open panel, allow closing by dragging it
            const rectLeft = sidebar.getBoundingClientRect();
            const rectRight = sidenotifEl.getBoundingClientRect();
            if (sidebar.classList.contains('open') && startX <= rectLeft.right) { draggingPanel = 'left'; sidebar.classList.add('dragging'); }
            else if (sidenotifEl.classList.contains('open') && startX >= rectRight.left) { draggingPanel = 'right'; sidenotifEl.classList.add('dragging'); }
          }
        }
      }

      function onTouchMove(e) {
        if (!touching || !draggingPanel || !e.touches || e.touches.length !== 1) return;
        currentX = e.touches[0].clientX;
        const dx = currentX - startX;

        if (draggingPanel === 'left') {
          // When closed, panel moves from -width to -width + dx (but clamped)
          const w = sidebar.offsetWidth;
          let translate = -w + Math.max(0, dx); // dx positive pulls it in
          // If panel already open and dx negative, allow closing with negative dx
          if (sidebar.classList.contains('open')) {
            translate = Math.min(0, dx); // dx negative moves it left to hide
          }
          // clamp
          translate = Math.min(0, Math.max(-w, translate));
          setTranslateX(sidebar, translate);
        } else if (draggingPanel === 'right') {
          const w = sidenotifEl.offsetWidth;
          let translate = w + Math.min(0, dx); // when closed dx negative pulls it in
          if (sidenotifEl.classList.contains('open')) {
            translate = Math.max(0, dx); // dx positive moves it right to hide
          }
          // translateX should be between 0 (open) and w (hidden)
          translate = Math.max(0, Math.min(w, translate));
          // convert to CSS value: we want translateX(translate) but for right panel initial closed state is +w px -> we use translateX(translate)
          setTranslateX(sidenotifEl, translate + 'px'); // keep px as string
        }
      }

      function onTouchEnd() {
        if (!touching || !draggingPanel) { touching = false; draggingPanel = null; return; }
        const dx = currentX - startX;
        if (draggingPanel === 'left') {
          const w = sidebar.offsetWidth;
          const opened = (sidebar.classList.contains('open')) ? (dx > -w * (1 - OPEN_THRESHOLD_RATIO)) : (dx > w * OPEN_THRESHOLD_RATIO);
          if (opened) {
            sidebar.classList.add('open');
            sidebar.style.transform = ''; // let CSS class handle transform
          } else {
            sidebar.classList.remove('open');
            sidebar.style.transform = ''; // reset
            hideOverlayIfClosed();
          }
          sidebar.classList.remove('dragging');
        } else if (draggingPanel === 'right') {
          const w = sidenotifEl.offsetWidth;
          const opened = (sidenotifEl.classList.contains('open')) ? (dx < w * (1 - OPEN_THRESHOLD_RATIO)) : (dx < -w * OPEN_THRESHOLD_RATIO);
          if (opened) {
            sidenotifEl.classList.add('open');
            sidenotifEl.style.transform = '';
          } else {
            sidenotifEl.classList.remove('open');
            sidenotifEl.style.transform = '';
            hideOverlayIfClosed();
          }
          sidenotifEl.classList.remove('dragging');
        }
        touching = false;
        draggingPanel = null;
      }

      // Attach global touch events (for edge swipes)
      document.addEventListener('touchstart', onTouchStart, { passive: true });
      document.addEventListener('touchmove', onTouchMove, { passive: true });
      document.addEventListener('touchend', onTouchEnd, { passive: true });
      document.addEventListener('touchcancel', onTouchEnd, { passive: true });

      // existing click handlers (kept)
      const burgerBtn = document.querySelector('.header .burger');
      const closeBtn = document.querySelector('.sidebar .close-sidebar');
      const notifBtn = document.querySelector('.notif-user');

      function openSidebar() { sidebar.classList.add('open'); showOverlay(); }
      function closeSidebar() { sidebar.classList.remove('open'); hideOverlayIfClosed(); }
      function openNotif() { sidenotifEl.classList.add('open'); showOverlay(); }
      function closeNotif() { sidenotifEl.classList.remove('open'); hideOverlayIfClosed(); }

      if (burgerBtn) burgerBtn.addEventListener('click', (e) => { e.stopPropagation(); openSidebar(); });
      if (closeBtn) closeBtn.addEventListener('click', (e) => { e.stopPropagation(); closeSidebar(); });
      if (notifBtn) notifBtn.addEventListener('click', (e) => { e.stopPropagation(); if (sidenotifEl.classList.contains('open')) closeNotif(); else openNotif(); });

      // close if overlay tapped
      filterOverlay.addEventListener('click', () => { closeSidebar(); closeNotif(); });

      // close with Escape for accessibility
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { closeSidebar(); closeNotif(); }
      });

      // When panels are opened programmatically, ensure overlay visible
      const observer = new MutationObserver(() => {
        if (sidebar.classList.contains('open') || sidenotifEl.classList.contains('open')) showOverlay();
        else hideOverlayIfClosed();
      });
      observer.observe(sidebar, { attributes: true, attributeFilter: ['class'] });
      observer.observe(sidenotifEl, { attributes: true, attributeFilter: ['class'] });
    })();

  </script>

  <!-- ======= BLOQUET 1 : Variables ======= -->
  <script>
    window.STATUS_MAP = {
      'en impression': { label: 'En cours', icon: '../img/icon/pointorange.png' },
      'en stock': { label: 'Disponible', icon: '../img/icon/pointvert.png' },
      'en quarentaine': { label: 'A confirmer', icon: '../img/icon/pointrouge.png' },
      'indisponible': { label: 'Indisponible', icon: '../img/icon/pointrouge.png' },
      'en sous-traitance': { label: 'Sous-traitance', icon: '../img/icon/pointsous.png' },
      'comandees': { label: 'Commandées', icon: '../img/icon/pointbleu.png' }
    };

    window.DEFAULT_IMG = '../img/icon/papeterie-papiers-empiles.png';

    window.STATUS_OPTIONS = [
      { key: 'en_stock', label: 'En stock', sub: 'Disponible', color: '#10b981', icon: '../img/icon/pointvert.png' },
      { key: 'en_impression', label: 'En impression', sub: 'Sur presse', color: '#f59e0b', icon: '../img/icon/pointorange.png' },
      { key: 'en_sous_traitance', label: 'Sous-traitance', sub: 'Chez le sous-traitant', color: '#6b21a8', icon: '../img/icon/pointsous.png' },
      { key: 'en_quarantaine', label: 'Quarantaine', sub: 'A vérifier', color: '#ef4444', icon: '../img/icon/pointrouge.png' },
      { key: 'indisponible', label: 'Indisponible', sub: 'Non disponible', color: '#374151', icon: '../img/icon/pointrouge.png' },
      { key: 'comandees', label: 'Commandées', sub: 'Commande en cours', color: '#0f1724', icon: '../img/icon/pointbleu.png' }
    ];

    // conserve une copie immuable de la source initiale (si fournie par le serveur)
    window._PLAQUES_DB_SOURCE = window._PLAQUES_DB_SOURCE || (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB.slice() : []);

  </script>

  <!-- BLOQUET 2 : FIX: integration + fallback SimpleMultiSelect autonome -->
  <script>
    (function () {
      'use strict';

      window.setSearchButtonState = window.setSearchButtonState || function (btn, can) {
        if (!btn) return;
        // On évite de définir btn.disabled = true pour conserver le click handler actif.
        btn.disabled = false;
        btn.setAttribute('aria-disabled', can ? 'false' : 'true');
        btn.classList.toggle('btn-disabled', !can);
      };

      // Primary endpoints (suivi.py)
      const URL_CLIENTS_RAW = '/suivi/clients/raw';
      const URL_PRODUITS_RAW = '/suivi/produits/raw';
      // Fallback endpoints (in case raw endpoints are not present)
      const URL_CLIENTS = '/suivi/clients';
      const URL_PRODUITS = '/suivi/produits';

      // --- minimal CSS for fallback component (safe, scoped) ---
      if (!document.getElementById('simple-ms-styles')) {
        const css = `
    .sms-container { display:inline-block; position:relative; font-family:inherit; }
    .sms-trigger { min-width:200px; min-height:44px; display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; border:1px solid rgba(0,0,0,0.08); background:linear-gradient(#fff,#fbfdff); cursor:pointer; box-sizing:border-box; }
    .sms-tags { display:flex; gap:6px; flex-wrap:wrap; max-width:420px; }
    .sms-tag { background:#f1f5f9; padding:4px 8px; border-radius:999px; font-size:13px; display:inline-flex; gap:6px; align-items:center; }
    .sms-caret { margin-left:auto; font-size:12px; color:rgba(0,0,0,0.45); }
    .sms-dropdown { position:absolute; z-index:2147483000; top:calc(100% + 8px); left:0; min-width:260px; background:#fff; border:1px solid rgba(0,0,0,0.06); border-radius:10px; box-shadow: 0 18px 40px rgba(2,6,23,0.08); padding:10px; box-sizing:border-box; }
    .sms-search { width:100%; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); margin-bottom:8px; }
    .sms-list { max-height:260px; overflow:auto; border-radius:8px; }
    .sms-row { display:flex; gap:8px; align-items:center; padding:8px; cursor:pointer; }
    .sms-row:hover { background: rgba(11,110,253,0.03); }
    .sms-row input { width:18px; height:18px; }
    .sms-empty { padding:12px; color: #64748b; text-align:center; }
    `;
        const st = document.createElement('style');
        st.id = 'simple-ms-styles';
        st.textContent = css;
        document.head.appendChild(st);
      }

      // --- tiny fetch helper ---
      async function fetchJSON(url) {
        try {
          const res = await fetch(url, { credentials: 'same-origin' });
          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
          return await res.json();
        } catch (err) {
          console.warn('fetchJSON failed', url, err);
          return null;
        }
      }

      function createOption(value, text, dataset = {}) {
        const o = document.createElement('option');
        o.value = value != null ? String(value) : '';
        o.textContent = text != null ? String(text) : '';
        Object.keys(dataset || {}).forEach(k => { o.dataset[k] = dataset[k]; });
        return o;
      }

      function normalize(s) { return (s || '').toString().trim().toLowerCase(); }

      // --- SimpleMultiSelect fallback (lightweight, exposes same essentials) ---
      class SimpleMultiSelect {
        constructor(selectEl) {
          this.select = selectEl;
          this.container = document.createElement('div');
          this.container.className = 'sms-container';
          this.trigger = document.createElement('div');
          this.trigger.className = 'sms-trigger';
          this.tagsWrap = document.createElement('div');
          this.tagsWrap.className = 'sms-tags';
          this.caret = document.createElement('div');
          this.caret.className = 'sms-caret';
          this.caret.innerHTML = '&#9662;';
          this.trigger.appendChild(this.tagsWrap);
          this.trigger.appendChild(this.caret);
          this.dropdown = document.createElement('div');
          this.dropdown.className = 'sms-dropdown';
          this.dropdown.style.display = 'none';
          this.search = document.createElement('input');
          this.search.className = 'sms-search';
          this.search.type = 'search';
          this.search.placeholder = 'Rechercher...';
          this.list = document.createElement('div');
          this.list.className = 'sms-list';
          this.dropdown.appendChild(this.search);
          this.dropdown.appendChild(this.list);
          this.container.appendChild(this.trigger);
          this.container.appendChild(this.dropdown);

          // insert in DOM after select
          this.select.parentNode.insertBefore(this.container, this.select.nextSibling);

          // read options (skip data-skip="1" placeholder)
          this.items = Array.from(this.select.options || []).filter(o => o.dataset.skip !== '1').map(o => ({
            id: (o.value != null && o.value !== '') ? String(o.value) : String(o.textContent || ''),
            label: String(o.textContent || o.value || ''),
            optionEl: o,
            selected: !!o.selected
          }));
          this.filteredItems = this.items.slice();
          this.opened = false;
          this._renderTags();
          this._renderList();
          this._attach();
        }

        _attach() {
          document.addEventListener('click', (e) => {
            if (!this.opened) return;
            if (this.container.contains(e.target)) return;
            this.close();
          });
          this.trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggle();
          });
          this.search.addEventListener('input', (e) => {
            const q = (e.target.value || '').trim().toLowerCase();
            this.filteredItems = this.items.filter(it => it.label.toLowerCase().includes(q));
            this._renderList();
          });
          this.list.addEventListener('click', (e) => {
            const row = e.target.closest('.sms-row');
            if (!row) return;
            const id = row.dataset.id;
            this._toggleById(id);
          });
          // keep native select in sync
          this.select.addEventListener('change', () => {
            // sync selection state from native if changed externally
            for (const it of this.items) {
              it.selected = !!it.optionEl.selected;
            }
            this._renderTags();
            this._renderList();
          });
        }

        _renderTags() {
          this.tagsWrap.innerHTML = '';
          const selected = this.items.filter(i => i.selected);
          if (!selected.length) {
            const p = document.createElement('span'); p.style.color = 'rgba(0,0,0,0.45)'; p.style.fontSize = '12px'; p.textContent = '-- Sélectionner --';
            this.tagsWrap.appendChild(p);
            return;
          }
          selected.forEach(it => {
            const t = document.createElement('span'); t.className = 'sms-tag'; t.dataset.id = it.id; t.title = it.label;
            t.innerHTML = `${it.label} <span style="cursor:pointer;margin-left:6px;font-weight:700">×</span>`;
            t.querySelector('span').addEventListener('click', (ev) => { ev.stopPropagation(); this._setSelectedById(it.id, false, { fromUI: true }); });
            this.tagsWrap.appendChild(t);
          });
        }

        _renderList() {
          this.list.innerHTML = '';
          if (!this.filteredItems.length) {
            const e = document.createElement('div'); e.className = 'sms-empty'; e.textContent = 'Aucun élément';
            this.list.appendChild(e); return;
          }
          this.filteredItems.forEach(it => {
            const r = document.createElement('div'); r.className = 'sms-row'; r.dataset.id = it.id;
            const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = !!it.selected; cb.tabIndex = -1;
            const lbl = document.createElement('div'); lbl.textContent = it.label; lbl.style.flex = '1';
            r.appendChild(cb); r.appendChild(lbl);
            // click on checkbox toggles
            cb.addEventListener('click', (ev) => { ev.stopPropagation(); this._setSelectedById(it.id, cb.checked, { fromUI: true }); });
            this.list.appendChild(r);
          });
        }

        _toggleById(id) {
          const it = this.items.find(x => String(x.id) === String(id)); if (!it) return;
          this._setSelectedById(id, !it.selected, { fromUI: true });
        }

        _setSelectedById(id, selected, opts = {}) {
          const it = this.items.find(x => String(x.id) === String(id)); if (!it) return;
          it.selected = !!selected;
          if (it.optionEl) it.optionEl.selected = !!selected;
          // update UI
          this._renderTags();
          this._renderList();
          // announce
          this._dispatchChange();
          if (opts.fromUI) {
            // keep focus on trigger
            this.trigger.focus();
          }
        }

        _dispatchChange() {
          try { this.select.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
          this.select.dispatchEvent(new CustomEvent('multi-select-change', { detail: { selected: this.getSelected() }, bubbles: true }));
        }

        getSelected() { return this.items.filter(i => i.selected).map(i => i.id); }
        setSelected(ids = []) {
          const set = new Set((Array.isArray(ids) ? ids : [ids]).map(String));
          for (const it of this.items) { it.selected = set.has(String(it.id)); if (it.optionEl) it.optionEl.selected = it.selected; }
          this._renderTags(); this._renderList(); this._dispatchChange();
        }
        clear() { for (const it of this.items) { it.selected = false; if (it.optionEl) it.optionEl.selected = false; } this._renderTags(); this._renderList(); this._dispatchChange(); }
        open() { if (this.opened) return; this.opened = true; this.dropdown.style.display = 'block'; this.search.focus(); }
        close() { if (!this.opened) return; this.opened = false; this.dropdown.style.display = 'none'; }
        toggle() { this.opened ? this.close() : this.open(); }
      }

      // --- populate selects then init either real EMS or fallback SimpleMultiSelect ---
      async function populateAndInit() {
        const selectsContainer = document.querySelector('.select-clientsproduct') || document.querySelector('.em-selects');
        const plaquesWrap = document.querySelector('.plaques');
        if (!selectsContainer || !plaquesWrap) {
          console.warn('selectsContainer ou plaques introuvable'); return;
        }
        const selects = Array.from(selectsContainer.querySelectorAll('select'));
        const clientSelect = selects[0]; const productSelect = selects[1];
        if (!clientSelect || !productSelect) { console.warn('deux <select> attendus'); return; }

        // ensure multiple (semantic)
        clientSelect.multiple = true; productSelect.multiple = true;

        // try raw endpoints first (compat with conception.py style), else fallback
        const [clientsRaw, prodsRaw] = await Promise.all([
          fetchJSON(URL_CLIENTS_RAW).then(r => r === null ? fetchJSON(URL_CLIENTS) : r).catch(() => null),
          fetchJSON(URL_PRODUITS_RAW).then(r => r === null ? fetchJSON(URL_PRODUITS) : r).catch(() => null)
        ]);

        const idToClient = {}; const idToProd = {};

        // tolerant normalization: handle various field names
        if (Array.isArray(clientsRaw) && clientsRaw.length) {
          clientsRaw.forEach(c => {
            // possible keys: id_client, id, enseigne, name, nom, enseigne
            const id = c.id_client || c.id || c.uuid || c.id_client_str || null;
            const label = c.enseigne || c.name || c.nom || c.enseigne_fr || '';
            if (!label) return;
            clientSelect.appendChild(createOption(id || label, label));
            if (id) idToClient[String(id)] = label;
          });
        }

        if (Array.isArray(prodsRaw) && prodsRaw.length) {
          prodsRaw.forEach(p => {
            const id = p.id_produit || p.id || p.uuid || null;
            const label = p.nom_produit || p.nom || p.name || '';
            if (!label) return;
            productSelect.appendChild(createOption(id || label, label));
            if (id) idToProd[String(id)] = label;
          });
        }

        // fallback from PLAQUES_DB if selects still essentially empty (only placeholder)
        if (clientSelect.options.length <= 1 && Array.isArray(window._PLAQUES_DB_SOURCE)) {
          const seen = new Set();
          (window._PLAQUES_DB_SOURCE || []).forEach(p => {
            const label = (p.client || '').toString().trim();
            if (!label || seen.has(label)) return; seen.add(label);
            clientSelect.appendChild(createOption(label, label));
          });
        }
        if (productSelect.options.length <= 1 && Array.isArray(window.PLAQUES_DB)) {
          const seen = new Set();
          (window.PLAQUES_DB || []).forEach(p => {
            const label = (p.produit || '').toString().trim();
            if (!label || seen.has(label)) return; seen.add(label);
            productSelect.appendChild(createOption(label, label));
          });
        }

        // Try to init official EnhancedMultiSelect if present
        const EMS = window.EnhancedMultiSelect && window.EnhancedMultiSelect.init ? window.EnhancedMultiSelect : null;
        if (EMS) {
          try {
            const instances = EMS.init([clientSelect, productSelect]);
            window.__clientEMS = instances[0] || null;
            window.__prodEMS = instances[1] || null;
          } catch (e) { console.warn('EMS.init failed, falling back', e); }
        }

        // Fallback to local simple UI if EMS didn't initialize
        if (!window.__clientEMS) {
          window.__clientEMS = new SimpleMultiSelect(clientSelect);
        }
        if (!window.__prodEMS) {
          window.__prodEMS = new SimpleMultiSelect(productSelect);
        }

        // hide native selects from view but keep accessible to screen readers
        [clientSelect, productSelect].forEach(s => {
          s.style.position = 'absolute'; s.style.left = '-9999px'; s.style.top = 'auto'; s.style.width = '1px'; s.style.height = '1px'; s.style.overflow = 'hidden';
          s.setAttribute('aria-hidden', 'true');
        });

        // hookup search button and filtering (behaviour identical to before)
        const searchBTN = document.getElementById('searchBTN');
        window.hasSearched = window.hasSearched || false;
        function getSelectedLabels(emInstance) {
          if (!emInstance) return [];
          const vals = (typeof emInstance.getSelected === 'function' ? emInstance.getSelected() : []);
          return vals.map(v => {
            // try to resolve label via option element if possible
            const optList = Array.from((emInstance.select || document.createElement('select')).options);
            const opt = optList.find(o => String(o.value) === String(v));
            const label = opt ? opt.textContent.trim() : String(v || '').trim();
            return normalize(label);
          }).filter(Boolean);
        }
        function evaluateAndRender() {
          const clientList = getSelectedLabels(window.__clientEMS);
          const productList = getSelectedLabels(window.__prodEMS);
          if (!(clientList.length || productList.length)) { window.hidePlaques && window.hidePlaques(); return; }
          const source = Array.isArray(window._PLAQUES_DB_SOURCE) && window._PLAQUES_DB_SOURCE.length ? window._PLAQUES_DB_SOURCE : (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : []);
          const filtered = (source).filter(p => {
            const pc = normalize(p.client); const pp = normalize(p.produit);
            const matchC = clientList.length ? clientList.some(c => c === pc) : true;
            const matchP = productList.length ? productList.some(q => q === pp) : true;
            return matchC && matchP;
          });
          window.renderPlaques && window.renderPlaques(filtered);
          window.showPlaques && window.showPlaques();
        }
        function updateSearchState() {
          const c = getSelectedLabels(window.__clientEMS).length;
          const p = getSelectedLabels(window.__prodEMS).length;
          const can = !!(c || p);
          // utilise le helper global au lieu de disabled natif
          window.setSearchButtonState(searchBTN, can);
        }

        [window.__clientEMS, window.__prodEMS].forEach(inst => {
          if (!inst) return;
          // listen for native select events / custom events
          inst.select.addEventListener('multi-select-change', updateSearchState);
          inst.select.addEventListener('change', updateSearchState);
        });

        if (searchBTN) {
          searchBTN.addEventListener('click', (ev) => {
            ev.preventDefault();

            const codeInput = document.querySelector('.em-code-search input');
            const plaqueNumber = codeInput ? (codeInput.value || '').trim() : '';

            // Si un numéro est saisi, lance la recherche par numéro comme l'Enter
            if (plaqueNumber) {
              // Priorité : appeler la fonction de recherche par numéro si disponible
              if (typeof window.findPlaqueNumero === 'function') {
                // safe : findPlaqueNumero retourne une Promise
                window.findPlaqueNumero(plaqueNumber).catch(err => {
                  console.error('Erreur recherche plaque via findPlaqueNumero:', err);
                  alert('Erreur lors de la recherche par numéro (voir console).');
                });
              } else {
                // fallback ultime : essaye la fonction locale searchPlaqueAndReveal si définie
                if (typeof searchPlaqueAndReveal === 'function') {
                  searchPlaqueAndReveal(plaqueNumber).catch(err => {
                    console.error('Erreur searchPlaqueAndReveal:', err);
                    alert('Erreur lors de la recherche par numéro (voir console).');
                  });
                } else {
                  // message informatif uniquement si aucune fonction dispo
                  alert('Recherche par numéro indisponible dans ce contexte.');
                }
              }
              return;
            }

            // Vérifier si on est "visuellement" disabled via aria-disabled (pas via disabled)
            const isAriaDisabled = searchBTN.getAttribute('aria-disabled') === 'true';

            // Récupération des sélections
            const clientList = getSelectedLabels(window.__clientEMS);
            const productList = getSelectedLabels(window.__prodEMS);

            if (isAriaDisabled || (clientList.length === 0 && productList.length === 0)) {
              // montre l'alerte même si le bouton est "gris"
              alert('Veuillez sélectionner au moins un client ou un produit, ou entrer un numéro de plaque.');
              return;
            }

            // Lancer la recherche normale
            window.hasSearched = true;
            evaluateAndRender && evaluateAndRender();
            if (plaquesWrap && plaquesWrap.children.length) window.showPlaques && window.showPlaques();
          });
        }

        // initial UI
        updateSearchState();
        window.renderPlaques && window.renderPlaques(window.PLAQUES_DB || []);
      }

      // run on DOM ready
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', populateAndInit);
      else populateAndInit();

    })();
  </script>

  <!-- ======= BLOQUET Recherche plaque: Initialisation DOM & listeners (principal) =======
     (se lance au DOMContentLoaded; utilise les helpers / composants définis plus haut) -->
  <script>
    /* ===== Recherche N° Plaque : ouverture conception + highlight (version préservant les autres plaques) ===== */
    (function () {
      if (!document.getElementById('plaque-search-highlight-styles')) {
        const css = `
    @keyframes plaque-shake { 0%{transform:translateX(0)}20%{transform:translateX(-8px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(2px)}100%{transform:translateX(0)} }
    .plaque-found-highlight{
      animation: plaque-shake 700ms ease;
      box-shadow: 0 12px 30px rgba(16,185,129,0.12), 0 4px 10px rgba(2,6,23,0.06);
      border-left: 6px solid #bbf7d0 !important;
      outline: 2px solid rgba(16,185,129,0.12);
      transition: box-shadow 220ms ease, outline 220ms ease;
      position: relative; z-index: 2;
    }`;
        const st = document.createElement('style'); st.id = 'plaque-search-highlight-styles'; st.textContent = css; document.head.appendChild(st);
      }

      function normalizeNumberInput(v) {
        if (v === null || v === undefined) return null;
        const s = String(v).trim();
        if (!s) return null;
        const asNum = Number(s);
        if (!Number.isNaN(asNum) && Number.isFinite(asNum)) return asNum;
        return s;
      }

      function findPlaqueLocal(matchVal) {
        if (matchVal == null) return null;
        const arrs = [window.PLAQUES_DB, window.PLAQUES_DB_DISPLAY, window._PLAQUES_DB_SOURCE];
        for (const arr of arrs) {
          if (!Array.isArray(arr)) continue;
          for (const p of arr) {
            if (!p) continue;
            if (String(p.numero_plaque) === String(matchVal) || String(p.numero) === String(matchVal) ||
              String(p.code) === String(matchVal) || String(p.id_plaque) === String(matchVal)) return p;
          }
        }
        const domRows = document.querySelectorAll('.suivi-plaque, .plaque');
        for (const r of domRows) {
          try {
            const codeEl = r.querySelector && (r.querySelector('.suivi-plaque__code') || r.querySelector('.code'));
            const code = codeEl ? codeEl.textContent.trim() : null;
            if (code && String(code) === String(matchVal)) {
              const idPl = r.dataset.idPl || r.dataset.id || null;
              const conceptionId = r.dataset.idConception || null;
              return { id_plaque: idPl, numero_plaque: matchVal, id_conception: conceptionId, nom_conception: null, __from_dom: true };
            }
          } catch (e) { }
        }
        return null;
      }

      async function fetchPlaqueFromServerByNumero(numero) {
        try {
          const url = '/suivi/plaques?numero_plaque=' + encodeURIComponent(String(numero));
          const res = await fetch(url, { credentials: 'same-origin' });
          if (!res.ok) return null;
          const json = await res.json();
          if (Array.isArray(json) && json.length) return json[0];
          return null;
        } catch (e) { console.warn('fetchPlaqueFromServerByNumero failed', e); return null; }
      }

      async function fetchPlaquesForConception(conceptionId) {
        try {
          const url = '/suivi/conceptions/' + encodeURIComponent(String(conceptionId)) + '/plaques';
          const res = await fetch(url, { credentials: 'same-origin' });
          if (!res.ok) return null;
          const json = await res.json();
          if (Array.isArray(json)) return json;
          return null;
        } catch (e) { console.warn('fetchPlaquesForConception failed', e); return null; }
      }

      function normalizeServerPlaque(p) {
        if (!p) return null;
        return {
          id_plaque: String(p.id_plaque || p.id || ''),
          numero_plaque: p.numero_plaque ?? p.numero ?? p.numeroPlaque ?? null,
          id_conception: p.id_conception || (p.conception && p.conception.id_conception) || null,
          nom_conception: p.nom_conception || (p.conception && p.conception.nom_conception) || null,
          statut: p.statut ?? p.status ?? p.etat ?? null,
          __raw: p
        };
      }

      // merge plaques into PLAQUES_DB without duplicates (replace existing by id)
      function mergePlaquesIntoMaster(plaqs) {
        if (!Array.isArray(plaqs)) return;
        window.PLAQUES_DB = Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : [];
        for (const p of plaqs) {
          const norm = normalizeServerPlaque(p);
          if (!norm) continue;
          const idx = window.PLAQUES_DB.findIndex(x => String(x.id_plaque) === String(norm.id_plaque) || (String(x.numero_plaque) === String(norm.numero_plaque) && x.id_conception === norm.id_conception));
          if (idx === -1) window.PLAQUES_DB.push(norm);
          else Object.assign(window.PLAQUES_DB[idx], norm);
        }
      }

      // ensure display set contains ALL plaques for a given conception id (adds missing from master)
      function ensureConceptionFullyVisibleInDisplay(conceptionId) {
        window.PLAQUES_DB_DISPLAY = Array.isArray(window.PLAQUES_DB_DISPLAY) ? window.PLAQUES_DB_DISPLAY.slice() : (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB.slice() : []);
        const master = Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : [];
        const toAdd = master.filter(m => String(m.id_conception) === String(conceptionId) && !window.PLAQUES_DB_DISPLAY.find(d => String(d.id_plaque) === String(m.id_plaque)));
        if (toAdd.length) window.PLAQUES_DB_DISPLAY = window.PLAQUES_DB_DISPLAY.concat(toAdd);
        return window.PLAQUES_DB_DISPLAY;
      }

      // open group and find row (unchanged behaviour)
      function openConceptionAndFindRow(plaqueObj) {
        if (!plaqueObj) return null;
        const idConception = plaqueObj.id_conception || plaqueObj.idConception || plaqueObj.id_conception;
        const codeToMatch = String(plaqueObj.numero_plaque ?? plaqueObj.numero ?? plaqueObj.code ?? '').trim();
        let group = null;
        if (idConception) {
          try { group = document.querySelector(`.suivi-conception[data-conception="${CSS.escape(String(idConception))}"]`); } catch (e) { }
        }
        if (!group) {
          const nodes = document.querySelectorAll('.suivi-conception');
          for (const n of nodes) {
            const tit = (n.querySelector && n.querySelector('.suivi-conception__title')) ? n.querySelector('.suivi-conception__title').textContent.trim() : '';
            if (tit && plaqueObj.nom_conception && tit === String(plaqueObj.nom_conception).trim()) { group = n; break; }
          }
        }
        if (!group) {
          const rowCandidate = Array.from(document.querySelectorAll('.suivi-plaque')).find(r => {
            const codeEl = r.querySelector && (r.querySelector('.suivi-plaque__code') || r.querySelector('.code'));
            return codeEl && String(codeEl.textContent || '').trim() === codeToMatch;
          });
          if (rowCandidate) group = rowCandidate.closest('.suivi-conception') || null;
        }
        if (!group) return null;
        if (!group.classList.contains('open')) {
          const head = group.querySelector('.suivi-conception__head');
          if (head) head.click();
        }
        const row = Array.from(group.querySelectorAll('.suivi-plaque')).find(r => {
          const rid = String(r.dataset.idPl || r.dataset.id || r.dataset.idpl || '').trim();
          const codeEl = r.querySelector && (r.querySelector('.suivi-plaque__code') || r.querySelector('.code'));
          const codeText = codeEl ? String(codeEl.textContent || '').trim() : '';
          return (rid && String(rid) === String(plaqueObj.id_plaque)) || (codeText && String(codeText) === String(codeToMatch));
        });
        return row || null;
      }

      function highlightRow(row) {
        if (!row) return;
        document.querySelectorAll('.plaque-found-highlight').forEach(n => n.classList.remove('plaque-found-highlight'));
        row.classList.add('plaque-found-highlight');
        try { row.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
        try { row.focus({ preventScroll: true }); } catch (e) { }
        setTimeout(() => { try { row.classList.remove('plaque-found-highlight'); } catch (e) { } }, 4000);
      }

      // Main search function
      async function searchPlaqueAndReveal(rawVal) {
        const val = normalizeNumberInput(rawVal);
        if (val == null || val === '') { alert('Veuillez entrer un numéro de plaque à rechercher.'); return; }

        let found = findPlaqueLocal(val);
        if (!found) {
          found = await fetchPlaqueFromServerByNumero(val);
        }

        if (!found) {
          alert('Aucune plaque existante pour ce numéro.');
          return;
        }

        // If server returned a plaque object shape, normalize & merge to master
        try {
          if (found && !found.__from_dom) {
            // merge single plaque into master (safe)
            mergePlaquesIntoMaster([found]);
          }
        } catch (e) { console.warn('merge single failed', e); }

        // Ensure full conception plaques are present in display before rendering (so dropdown shows all plaques)
        const conceptionId = found.id_conception || found.idConception || (found.conception && (found.conception.id_conception || found.conception.id)) || null;

        // if we have a conception id, try fetching its plaques from server (best effort) then merge
        if (conceptionId) {
          try {
            const fetched = await fetchPlaquesForConception(conceptionId);
            if (Array.isArray(fetched) && fetched.length) {
              mergePlaquesIntoMaster(fetched);
            }
          } catch (e) { /* ignore */ }
        }

        // Build the display set:
        // - start from PLAQUES_DB_DISPLAY (if exists) to preserve current filters
        // - then ensure all plaques of the target conception are appended so the group shows all plaques
        let display = Array.isArray(window.PLAQUES_DB_DISPLAY) ? window.PLAQUES_DB_DISPLAY.slice() : (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB.slice() : []);
        if (conceptionId) {
          // add any master plaques from that conception that are missing in display
          const master = Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : [];
          const missing = master.filter(m => String(m.id_conception) === String(conceptionId) && !display.find(d => String(d.id_plaque) === String(m.id_plaque)));
          if (missing.length) display = display.concat(missing);
        }

        // re-render using the computed display (without removing other unrelated plaques)
        try {
          if (typeof window.renderPlaques === 'function') window.renderPlaques(display);
          else console.warn('renderPlaques absent - cannot render');
        } catch (e) { console.warn('renderPlaques failed', e); }

        // small delay to allow DOM to render, then open group + highlight row
        const attemptOpen = () => {
          const row = openConceptionAndFindRow(found);
          if (row) {
            if (typeof window.showPlaques === 'function') window.showPlaques();
            highlightRow(row);
          } else {
            let retries = 0;
            const t = setInterval(() => {
              retries++;
              const r = openConceptionAndFindRow(found);
              if (r) { clearInterval(t); if (typeof window.showPlaques === 'function') window.showPlaques(); highlightRow(r); }
              if (retries > 8) { clearInterval(t); console.warn('Impossible de localiser la ligne DOM pour la plaque trouvée.'); }
            }, 180);
          }
        };
        setTimeout(attemptOpen, 120);
      }

      // attach handlers to input + icon
      function attachPlaqueSearchHandlers() {
        const codeBloc = document.querySelector('.em-code-search');
        if (!codeBloc) return;
        const codeInput = codeBloc.querySelector('input[type="number"], input[type="text"], input') || null;
        const searchIcon = codeBloc.querySelector('.icon-search');

        if (codeInput) {
          codeInput.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); searchPlaqueAndReveal(codeInput.value).catch(e => console.error(e)); }
          });
        }
        if (searchIcon) {
          searchIcon.style.cursor = 'pointer';
          searchIcon.addEventListener('click', (ev) => { ev.preventDefault(); searchPlaqueAndReveal(codeInput ? codeInput.value : '').catch(e => console.error(e)); });
        }
        window.findPlaqueNumero = function (n) { return searchPlaqueAndReveal(n); };
      }

      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attachPlaqueSearchHandlers);
      else attachPlaqueSearchHandlers();

    })();
  </script>


  <!-- ======= BLOQUET 3: Initialisation DOM & listeners (principal) =======
     (se lance au DOMContentLoaded; utilise les helpers / composants définis plus haut) -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {

      /* ========== Sélecteurs adaptatifs (DOM queries) ========== */
      const selectsContainer = document.querySelector('.select-clientsproduct') || document.querySelector('.em-selects');
      const plaquesWrap = document.querySelector('.plaques');
      if (!selectsContainer || !plaquesWrap) {
        console.warn('selectsContainer ou plaquesWrap introuvable — vérifie les classes .select-clientsproduct / .em-selects et .plaques');
        return;
      }
      const selects = Array.from(selectsContainer.querySelectorAll('select'));
      const clientSelect = selects[0] || null;
      const productSelect = selects[1] || null;

      // NOTE: on garde l'input DOM mais on désactive toute logique de redirection liée au numéro de plaque
      const codeBloc = document.querySelector('.em-code-search') || document.querySelector('.code-select-plaque');
      const codeInput = codeBloc ? codeBloc.querySelector('input[type="number"], input[type="text"], input') : null;

      window.hasSearched = window.hasSearched || false;
      const searchBTN = document.getElementById('searchBTN') || document.querySelector('button#searchBTN');

      // Show/hide panneau plaques initialization (mises à disposition globales ensuite)
      plaquesWrap.style.transition = plaquesWrap.style.transition || 'opacity 180ms ease, transform 200ms ease';
      plaquesWrap.style.transformOrigin = 'top center';
      if (getComputedStyle(plaquesWrap).display === 'none') {
        plaquesWrap.dataset.visible = 'false';
        plaquesWrap.style.opacity = '0';
        plaquesWrap.style.transform = 'translateY(-8px)';
      } else {
        plaquesWrap.dataset.visible = 'true';
        plaquesWrap.style.opacity = '1';
        plaquesWrap.style.transform = 'translateY(0)';
      }

      function _showPlaquesLocal() {
        if (plaquesWrap.dataset.visible === 'true') return;
        plaquesWrap.dataset.visible = 'true';
        plaquesWrap.style.display = 'block';
        plaquesWrap.style.opacity = '0';
        plaquesWrap.style.transform = 'translateY(-8px)';
        requestAnimationFrame(() => {
          plaquesWrap.style.opacity = '1';
          plaquesWrap.style.transform = 'translateY(0)';
        });
      }
      function _hidePlaquesLocal() {
        if (plaquesWrap.dataset.visible !== 'true') return;
        plaquesWrap.dataset.visible = 'false';
        plaquesWrap.style.opacity = '0';
        plaquesWrap.style.transform = 'translateY(-8px)';
        const onEnd = (e) => {
          if (e.propertyName === 'opacity' || e.propertyName === 'transform') {
            plaquesWrap.style.display = 'none';
            plaquesWrap.removeEventListener('transitionend', onEnd);
          }
        };
        plaquesWrap.addEventListener('transitionend', onEnd);
      }

      // expose global helpers pour compatibilité avec buildPlaqueElement (qui est dans un autre bloc)
      window.showPlaques = _showPlaquesLocal;
      window.hidePlaques = _hidePlaquesLocal;

      /* ========== Helpers spécifiques au scope (utilisent window.*) ========== */
      const getSelectedValues = (selectEl, emInstance) => {
        if (emInstance && typeof emInstance.getSelected === 'function') {
          return emInstance.getSelected().map(s => (s || '').toString().trim().toLowerCase()).filter(Boolean);
        }
        if (!selectEl) return [];
        const opts = Array.from(selectEl.selectedOptions || []);
        return opts.map(o => (o.value || o.textContent || '').toString().trim().toLowerCase()).filter(Boolean);
      };

      /* ========== Filtrage (adapte pour multi-sélection) ========== */
      const evaluate = () => {
        if (!hasSearched) {
          window.hidePlaques();
          return;
        }

        const clientList = getSelectedValues(clientSelect, window.__clientEMS || null);
        const productList = getSelectedValues(productSelect, window.__prodEMS || null);

        const anySelected = !!(clientList.length || productList.length);
        if (!anySelected) { window.hidePlaques(); return; }

        const source = Array.isArray(window._PLAQUES_DB_SOURCE) && window._PLAQUES_DB_SOURCE.length ? window._PLAQUES_DB_SOURCE : (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : []);
        const filtered = (source).filter(p => {
          const pClient = (p.client || '').toString().trim().toLowerCase();
          const pProd = (p.produit || '').toString().trim().toLowerCase();

          const matchClient = clientList.length ? clientList.some(sel => sel === pClient) : true;
          const matchProd = productList.length ? productList.some(sel => sel === pProd) : true;
          return matchClient && matchProd;
        });

        window.renderPlaques(filtered);
        window.showPlaques();
      };

      /* ========== Activation / désactivation du bouton Chercher ==========
         - bouton désactivé si aucun select n'a de sélection (placeholder)
         - réagit aux événements multi-select-change + change natif */
      function updateSearchButtonState() {
        if (!searchBTN) return;
        const clientList = getSelectedValues(clientSelect, window.__clientEMS || null);
        const productList = getSelectedValues(productSelect, window.__prodEMS || null);
        const plaqueNumber = codeInput ? (codeInput.value || '').trim() : '';
        const canSearch = !!(clientList.length || productList.length || plaqueNumber);

        // utilise le helper global pour aspect visuel, conserve click handler actif
        window.setSearchButtonState(searchBTN, canSearch);
      }

      /* ========== Listeners pour selects (gère EnhancedMultiSelect events + native) ========== */
      if (clientSelect) {
        clientSelect.addEventListener('change', () => { window.clearInvalid(codeInput); updateSearchButtonState(); });
        clientSelect.addEventListener('input', () => { updateSearchButtonState(); });
        clientSelect.addEventListener('multi-select-change', () => { updateSearchButtonState(); });
      }
      if (productSelect) {
        productSelect.addEventListener('change', () => { updateSearchButtonState(); });
        productSelect.addEventListener('input', () => { updateSearchButtonState(); });
        productSelect.addEventListener('multi-select-change', () => { updateSearchButtonState(); });
      }

      if (codeInput) {
        codeInput.addEventListener('input', updateSearchButtonState);
      }

      /* ========== Recherche via bouton Chercher ==========
         - Ne fait rien si le bouton est désactivé
         - Lance evaluate() sinon */
      if (searchBTN) {
        searchBTN.addEventListener('click', (e) => {
          e.preventDefault();

          const plaqueNumber = codeInput ? (codeInput.value || '').trim() : '';

          if (plaqueNumber) {
            // Recherche par numéro (fonction dédiée)
            if (typeof window.findPlaqueNumero === 'function') {
              window.findPlaqueNumero(plaqueNumber).catch(err => console.error('Erreur recherche plaque:', err));
            } else {
              console.error('La fonction findPlaqueNumero n\'est pas disponible.');
            }
            return;
          }

          // Lecture de l'état visuel (aria) et des selects
          const isAriaDisabled = searchBTN.getAttribute('aria-disabled') === 'true';
          const clientList = getSelectedValues(clientSelect, window.__clientEMS || null);
          const productList = getSelectedValues(productSelect, window.__prodEMS || null);

          if (isAriaDisabled || (clientList.length === 0 && productList.length === 0)) {
            alert('Veuillez remplir au moins un des champs : Client, Produit ou Numéro de plaque.');
            return;
          }

          // Lancer la recherche par client/produit
          window.hasSearched = true;
          if (typeof evaluate === 'function') evaluate();
          else if (typeof evaluateAndRender === 'function') evaluateAndRender();

          if (plaquesWrap && plaquesWrap.children.length) window.showPlaques && window.showPlaques();
        });
      }


      /* ========== Suppression / neutralisation de la recherche par numéro ==========
         - On ne redirige plus nulle part.
         - Si un code est saisi dans le champ global (em-code-search) : nous n'effectuons AUCUNE action de redirection.
         - Les listeners originaux sur codeInput / redirectWithCode ont été retirés. */
      // aucun listener pour codeInput ici (champ laissé inert)

      /* ========== Initialisation EnhancedMultiSelect et modal ======= */
      try {
        // init EMS instances (les selects doivent exister)
        const emInstances = window.EnhancedMultiSelect.init(selects, { /* options */ });
        window.__clientEMS = emInstances[0] || null;
        window.__prodEMS = emInstances[1] || null;
        selects.forEach(s => s.classList.add('sr-only'));
      } catch (err) {
        console.warn('EnhancedMultiSelect.init failed :', err);
      }

      // init modal (création DOM + handlers)
      try {
        if (typeof window.initStatusModal === 'function') window.initStatusModal();
      } catch (e) {
        console.warn('initStatusModal failed', e);
      }

      /* ========== Lancement initial (render) ======= */
      window.renderPlaques(window.PLAQUES_DB || []);
      // initial update du bouton Chercher
      updateSearchButtonState();
      // on n'exécute pas evaluate() automatiquement (la page n'affiche les plaques que si l'utilisateur clique Chercher)
      // si tu veux garder l'ancien comportement d'affichage initial, active la ligne suivante :
      // evaluate();

      /* ========== decorate action buttons (ajoute icones aux boutons modifier) (inchangé) ========= */
      (function decorateActionButtons() {
        const ICONS = { edit: '../img/icon/editer.png' };
        function tryLoadIcon(src, cb) {
          const img = new Image();
          img.onload = () => cb(null, src);
          img.onerror = () => cb(new Error('not found'));
          img.src = src;
        }
        const plaquesWrapLocal = document.querySelector('.plaques');
        if (!plaquesWrapLocal) return;
        function decorate(nodeRoot) {
          nodeRoot.querySelectorAll('.btnEdit').forEach(btn => {
            if (btn.dataset._decorated) return;
            btn.dataset._decorated = '1';
            btn.setAttribute('aria-label', 'Modifier la plaque');
            const candidate = ICONS.edit;
            if (!candidate) return;
            tryLoadIcon(candidate, (err, src) => {
              if (err) return;
              const img = document.createElement('img');
              img.src = src;
              img.alt = '';
              img.setAttribute('aria-hidden', 'true');
              btn.insertBefore(img, btn.firstChild);
            });
          });
        }
        decorate(plaquesWrapLocal);
        const mo = new MutationObserver(muts => {
          for (const m of muts) {
            if (m.addedNodes && m.addedNodes.length) {
              m.addedNodes.forEach(n => {
                if (!(n instanceof HTMLElement)) return;
                if (n.matches && (n.matches('.plaque-expander') || n.matches('.plaque'))) decorate(n);
                else if (n.querySelector) decorate(n);
              });
            }
          }
        });
        mo.observe(plaquesWrapLocal, { childList: true, subtree: true });
      })();

    });
  </script>


  <script>
    (function () {
      'use strict';

      // ---------- safe fetch ----------
      async function fetchJSON(url) {
        try {
          const res = await fetch(url, { credentials: 'same-origin' });
          if (!res.ok) {
            console.warn('fetchJSON non ok', url, res.status);
            return { __error: true, status: res.status, text: await res.text().catch(() => null) };
          }
          return await res.json();
        } catch (err) {
          console.warn('fetchJSON failed', url, err);
          return { __error: true, err: String(err) };
        }
      }

      function looksLikeUUID(s) {
        if (!s) return false;
        return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(String(s).trim());
      }

      function getSelectedIds(instOrSelect) {
        if (!instOrSelect) return [];
        try {
          if (typeof instOrSelect.getSelected === 'function') {
            return (instOrSelect.getSelected() || []).map(String).filter(Boolean);
          }
        } catch (e) { }
        const sel = instOrSelect.select || instOrSelect;
        if (!sel) return [];
        return Array.from((sel.selectedOptions || [])).map(o => (o.value || o.textContent || '').toString()).filter(Boolean);
      }

      function labelForId(selectEl, id) {
        if (!selectEl) return null;
        const opt = Array.from(selectEl.options || []).find(o => String(o.value) === String(id));
        return opt ? (opt.textContent || '').trim() : null;
      }

      function dedupeBy(arr, keyFn) {
        const map = new Map();
        (arr || []).forEach(it => {
          const k = keyFn ? keyFn(it) : JSON.stringify(it);
          if (!map.has(k)) map.set(k, it);
        });
        return Array.from(map.values());
      }

      // ---------- fallback renderer (s'affiche si window.renderPlaques absent) ----------
      function fallbackRenderPlaques(plaques) {
        const wrap = document.querySelector('.plaques');
        if (!wrap) { console.warn('fallbackRender : .plaques introuvable'); return; }
        wrap.innerHTML = '';
        if (!Array.isArray(plaques) || !plaques.length) {
          wrap.innerHTML = '<div class="plaques-empty" style="padding:18px;color:#64748b">Chargement des plaques…</div>';
          wrap.style.display = 'none';
          return;
        }

        const list = document.createElement('div');
        list.style.display = 'grid';
        list.style.gridTemplateColumns = 'repeat(auto-fit,minmax(280px,1fr))';
        list.style.gap = '12px';

        plaques.forEach(p => {
          const card = document.createElement('div');
          card.className = 'plaque';
          card.style.border = '1px solid rgba(0,0,0,0.06)';
          card.style.padding = '12px';
          card.style.borderRadius = '8px';
          card.style.background = '#fff';
          card.style.boxShadow = '0 6px 18px rgba(2,6,23,0.04)';

          const title = document.createElement('div');
          title.style.display = 'flex';
          title.style.justifyContent = 'space-between';
          title.style.alignItems = 'center';
          title.innerHTML = `<div style="font-weight:700">N° ${escapeHtml(p.code || p.numero || p.numero_plaque || p.id_plaque || '')}</div>
                          <div style="font-size:12px;color:#6b7280">${escapeHtml(p.status || p.statut || '')}</div>`;
          card.appendChild(title);

          const meta = document.createElement('div');
          meta.style.marginTop = '8px';
          meta.style.fontSize = '13px';
          meta.style.color = '#374151';
          meta.innerHTML = `
          <div><strong>Conception:</strong> ${escapeHtml(p.nom_conception || p.conception || '')}</div>
          <div><strong>Machine:</strong> ${escapeHtml((p.machine && (p.machine.nom_machine || p.machine)) || '')}</div>
          <div><strong>Couleur:</strong> ${escapeHtml(p.couleur || '')}</div>
          <div><strong>Client:</strong> ${escapeHtml(p.client || '')}</div>
          <div><strong>Produit:</strong> ${escapeHtml(p.produit || '')}</div>
        `;
          card.appendChild(meta);

          list.appendChild(card);
        });

        wrap.appendChild(list);
        wrap.style.display = 'block';
      }

      function escapeHtml(s) {
        if (s === null || s === undefined) return '';
        return String(s).replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
      }

      // ---------- main search function with detailed logging ----------
      async function performSearchAndDebug() {
        console.log('[suivi/debug] démarrage recherche...');
        const plaquesWrap = document.querySelector('.plaques');
        const selectsContainer = document.querySelector('.select-clientsproduct') || document.querySelector('.em-selects');
        if (!selectsContainer || !plaquesWrap) {
          console.warn('[suivi/debug] éléments manquants .em-selects ou .plaques');
          return;
        }
        const selects = Array.from(selectsContainer.querySelectorAll('select'));
        const clientSelect = selects[0] || null;
        const productSelect = selects[1] || null;
        const clientEMS = window.__clientEMS || (clientSelect || null);
        const prodEMS = window.__prodEMS || (productSelect || null);

        const clientIds = getSelectedIds(clientEMS).map(String).filter(Boolean);
        const prodIds = getSelectedIds(prodEMS).map(String).filter(Boolean);
        console.log('[suivi/debug] clientIds=', clientIds, 'prodIds=', prodIds);

        if (!(clientIds.length || prodIds.length)) {
          console.log('[suivi/debug] rien de sélectionné -> on masque');
          if (window.hidePlaques) window.hidePlaques();
          return;
        }

        const anyClientUUID = clientIds.some(looksLikeUUID);
        const anyProdUUID = prodIds.some(looksLikeUUID);
        const useServer = anyClientUUID || anyProdUUID;
        console.log('[suivi/debug] useServer=', useServer);

        if (!useServer) {
          console.log('[suivi/debug] fallback local (labels non-UUID). PLQ_DB length before:', (window.PLAQUES_DB || []).length);
          // apply same local filter as before
          const clientListNorm = clientIds.map(s => (s || '').toString().trim().toLowerCase());
          const prodListNorm = prodIds.map(s => (s || '').toString().trim().toLowerCase());
          const source = Array.isArray(window._PLAQUES_DB_SOURCE) && window._PLAQUES_DB_SOURCE.length ? window._PLAQUES_DB_SOURCE : (Array.isArray(window.PLAQUES_DB) ? window.PLAQUES_DB : []);
          const filtered = (source).filter(p => {
            const pClient = (p.client || '').toString().trim().toLowerCase();
            const pProd = (p.produit || '').toString().trim().toLowerCase();
            const matchClient = clientListNorm.length ? clientListNorm.some(sel => sel === pClient) : true;
            const matchProd = prodListNorm.length ? prodListNorm.some(q => q === pProd) : true;
            return matchClient && matchProd;
          });
          console.log('[suivi/debug] local filtered length =', filtered.length);
          window.PLAQUES_DB_DISPLAY = filtered;
          if (typeof window.renderPlaques === 'function') {
            window.renderPlaques(filtered);
            window.showPlaques && window.showPlaques();
          } else {
            fallbackRenderPlaques(filtered);
          }
          return;
        }

        // Build server queries (AND semantics)
        const params = new URLSearchParams();
        // append client ids (only UUID-looking values)
        for (const c of clientIds) {
          if (looksLikeUUID(c)) params.append('client_id', c);
        }
        // append produit ids (only UUID-looking values)
        for (const p of prodIds) {
          if (looksLikeUUID(p)) params.append('produit_id', p);
        }
        const conceptionQueries = [];
        if ([...params].length) {
          const url = '/suivi/conceptions?' + params.toString();
          conceptionQueries.push(url);
        }
        console.log('[suivi/debug] conceptionQueries=', conceptionQueries);

        if (!conceptionQueries.length) {
          console.warn('[suivi/debug] aucune requête serveur construite');
          window.PLAQUES_DB = [];
          if (window.renderPlaques) window.renderPlaques([]);
          else fallbackRenderPlaques([]);
          return;
        }

        // fetch conceptions
        let conceptions = [];
        try {
          const responses = await Promise.all(conceptionQueries.map(q => fetchJSON(q).catch(() => null)));
          console.log('[suivi/debug] réponses conceptions brutes:', responses);
          for (const r of responses) {
            if (Array.isArray(r)) conceptions = conceptions.concat(r);
            else if (r && r.__error) console.warn('[suivi/debug] erreur réponse conception', r);
          }
        } catch (e) {
          console.warn('[suivi/debug] erreur fetch conceptions', e);
        }
        console.log('[suivi/debug] conceptions récupérées (avant dedupe)=', conceptions.length);

        if (!conceptions.length) {
          console.log('[suivi/debug] aucune conception trouvée');

          // vide les données globales
          window.PLAQUES_DB = [];

          // message spécifique : "Aucune conception et plaque trouvée"
          const wrap = document.querySelector('.plaques');
          const message = '<div class="plaques-empty" style="padding:18px;color:#64748b;font-weight:600;text-align:center">Aucune conception / plaque trouvée.</div>';

          if (wrap) {
            wrap.innerHTML = message;
            // on veut afficher le message — mettre visible
            wrap.style.display = 'block';
            wrap.style.opacity = '1';
            wrap.style.transform = 'translateY(0)';
            wrap.setAttribute('aria-live', 'polite');
          } else {
            // fallback
            if (typeof window.renderPlaques === 'function') {
              try { window.renderPlaques([]); } catch (e) { console.warn('renderPlaques failed', e); }
            } else {
              fallbackRenderPlaques([]);
            }
          }
          return;
        }

        // normaliser ids
        conceptions = dedupeBy(conceptions.map(c => {
          const id = c.id_conception || c.id || c.uuid || null;
          return Object.assign({}, c, { __id: id, id_conception: id });
        }), it => String(it.__id));
        const placeholders = conceptions.map(c => ({
          id_plaque: null,
          id_conception: c.id_conception,
          nom_conception: c.nom_conception || c.nom || c.name || '',
          __placeholder: true,
          image: c.image || null     // <- passe l'image du serveur vers la placeholder
        }));
        console.log('[suivi/debug] conceptions dedupées=', conceptions.length, conceptions.slice(0, 3));

        // fetch plaques for each conception
        const plaquePromises = conceptions.map(c => {
          const cid = c.id_conception || c.__id;
          if (!cid) return Promise.resolve([]);
          return fetchJSON('/suivi/conceptions/' + encodeURIComponent(cid) + '/plaques').catch(() => null);
        });

        let plaqueResults = [];
        plaqueResults = plaqueResults.concat(placeholders);
        try {
          const pr = await Promise.all(plaquePromises);
          console.log('[suivi/debug] réponses plaques brutes:', pr);
          for (const r of pr) {
            if (Array.isArray(r)) plaqueResults = plaqueResults.concat(r);
            else if (r && r.__error) console.warn('[suivi/debug] erreur réponse plaques', r);
          }
        } catch (e) {
          console.warn('[suivi/debug] erreur fetch plaques', e);
        }
        console.log('[suivi/debug] plaqueResults length (raw) =', plaqueResults.length);

        if (!plaqueResults.length) {
          console.log('[suivi/debug] aucune plaque renvoyée par le serveur');
          window.PLAQUES_DB = [];
          if (window.renderPlaques) window.renderPlaques([]);
          else fallbackRenderPlaques([]);
          return;
        }

        // Normalize objects: map numero_plaque -> code, statut -> status, etc.
        const plaquesNormalized = plaqueResults.map(p => {
          const numero = p ? (p.numero_plaque ?? p.numero ?? null) : null;
          const codeVal = (numero !== null && numero !== '') ? String(numero) : String(p?.id_plaque ?? p?.id ?? '');
          const conceptionName = p?.nom_conception ?? p?.conception?.nom_conception ?? p?.conception?.nom ?? null;

          return {
            id_plaque: p?.id_plaque ?? p?.id ?? null,
            id_conception: p?.id_conception ?? p?.conception?.id_conception ?? p?.conception?.id ?? null,
            code: codeVal,
            numero_plaque: numero,
            numero: numero,
            nom_conception: conceptionName,
            conception: conceptionName,
            image: p?.image ?? p?.storage_path ?? p?.filename ?? null,
            conception_image: p?.__raw?.conception?.image ?? (p?.conception && p.conception.image) ?? null,
            couleur: p?.couleur ?? p?.color ?? null,
            machine: (p?.machine && (p.machine.nom_machine ?? p.machine.name)) ?? p?.machine ?? null,
            prix_unitaire: p?.prix_unitaire ?? p?.prix ?? null,
            status: p?.statut ?? p?.status ?? p?.etat ?? null,
            nombre_pose: p?.nombre_pose ?? p?.pose ?? 1,
            client: (clientIds.length === 1) ? (labelForId(clientSelect, clientIds[0]) || null) : (p?.client ?? null),
            produit: (prodIds.length === 1) ? (labelForId(productSelect, prodIds[0]) || null) : (p?.produit ?? null),
            __raw: p,
            __placeholder: !!p?.__placeholder // conserve le flag placeholder
          };
        });

        // filtre les placeholders avant dédoublonnage/affichage
        const plaquesFiltered = plaquesNormalized.filter(p => !p.__placeholder);

        const plaques = dedupeBy(plaquesFiltered, r =>
          String(r.id_plaque || r.code || JSON.stringify([r.numero_plaque, r.id_conception]))
        );

        console.log('[suivi/debug] plaques normalisées count =', plaques.length, plaques.slice(0, 5));
        window.PLAQUES_DB = window.PLAQUES_DB_DISPLAY = plaques;


        // Try to use existing renderPlaques, else fallback
        if (typeof window.renderPlaques === 'function') {
          try {
            window.renderPlaques(plaques);
            window.showPlaques && window.showPlaques();
            console.log('[suivi/debug] utilisé window.renderPlaques');
          } catch (err) {
            console.error('[suivi/debug] renderPlaques a échoué, falling back', err);
            fallbackRenderPlaques(plaques);
          }
        } else {
          console.log('[suivi/debug] window.renderPlaques absent -> fallbackRenderPlaques');
          fallbackRenderPlaques(plaques);
        }

        // also scroll to result area for convenience
        try { plaquesWrap.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) { }
      }

      // attach to button safely (replace clone)
      function replaceButtonWithClone(btn) {
        if (!btn || !btn.parentNode) return btn;
        const clone = btn.cloneNode(true);
        btn.parentNode.replaceChild(clone, btn);
        return clone;
      }

      function attachDebugSearchHandler() {
        const searchBTN = document.getElementById('searchBTN') || document.querySelector('button#searchBTN');
        if (!searchBTN) { console.warn('[suivi/debug] searchBTN introuvable'); return; }
        const newBtn = replaceButtonWithClone(searchBTN);
        newBtn.addEventListener('click', (ev) => {
          if (newBtn.disabled) { ev.preventDefault(); return; }
          ev.preventDefault();
          performSearchAndDebug().catch(err => console.error('[suivi/debug] erreur performSearchAndDebug', err));
        });
        console.log('[suivi/debug] handler attaché au bouton Chercher');
      }

      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attachDebugSearchHandler);
      else attachDebugSearchHandler();

      // expose for debugging
      window._suivi_debug_run = performSearchAndDebug;

    })();
  </script>


  <script>
    (function () {
      'use strict';

      // override previous renderPlaques if present
      const STYLE_ID = 'suivi-conception-thumb-styles';
      if (!document.getElementById(STYLE_ID)) {
        const css = `
    /* head + thumb */
    .suivi-conception { border:1px solid rgba(0,0,0,0.06); border-radius:10px; margin:10px 0; background:#fff; overflow:hidden; }
    .suivi-conception__head { display:flex; gap:14px; align-items:center; justify-content:space-between; padding:12px 14px; cursor:pointer; user-select:none; min-height:80px; }
    .suivi-conception__head-left { display:flex; gap:12px; align-items:center; min-width:0; }
    .conception-thumb { width:80px; height:64px; flex:0 0 80px; border-radius:6px; background-size:cover; background-position:center; box-shadow:0 6px 18px rgba(2,6,23,0.04); overflow:hidden; display:flex; align-items:center; justify-content:center; background-color:#f8fafc; }
    .conception-thumb img { max-width:100%; max-height:100%; display:block; object-fit:cover; }
    .suivi-conception__title { font-weight:700; color:#0b1220; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:40ch; }
    .suivi-conception__count { font-size:13px; color:#475569; margin-left:10px; padding:6px 10px; border-radius:999px; background:rgba(2,6,23,0.03); }

    /* body */
    .suivi-conception__body { display:none; padding:10px 14px 14px; border-top:1px solid rgba(0,0,0,0.03); }
    .suivi-conception.open .suivi-conception__body { display:block; }

    /* plaque line */
    .suivi-plaques-list { display:block; gap:8px; }
    .suivi-plaque { display:flex; align-items:center; justify-content:space-between; padding:10px; border-radius:8px; margin-bottom:8px; cursor:pointer; background:#E6E6E6; border:1px solid rgba(2,6,23,0.04); transition: transform .18s ease, box-shadow .18s ease; }
    .suivi-plaque:hover { transform: translateY(-4px); box-shadow:0 10px 24px rgba(2,6,23,0.06); }
    .suivi-plaque__info { display:flex; gap:12px; align-items:center; flex:1; min-width:0; }
    .suivi-plaque__code { font-weight:700; width:96px; flex:0 0 96px; color:#0b1220; }

    /* meta & couleur */
    .suivi-plaque__meta { display: flex; gap: 8px; align-items: center; font-size:13px; color:#374151; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .suivi-plaque__color-dot { border-radius: 50%; width: 20px; height: 20px; flex: 0 0 20px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06); border: 1px solid rgba(0,0,0,0.04); display: inline-block; }

    /* status badge */
    .suivi-plaque__status { display:flex; align-items:center; gap:8px; margin-left:8px; flex-shrink:0; }
    .suivi-plaque__status-badge { display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px; font-size:12px; font-weight:600; background:rgba(255,255,255,0.85); border:1px solid rgba(0,0,0,0.04); box-shadow: 0 1px 2px rgba(2,6,23,0.03); color:#0b1220; }
    .suivi-plaque__status-dot { width:10px; height:10px; border-radius:50%; flex:0 0 10px; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.15); }
    .suivi-plaque__status-icon { width:14px; height:14px; flex:0 0 14px; object-fit:contain; }

    .suivi-plaque__actions { display:flex; gap:8px; align-items:center; margin-left:12px; }
    .suivi-plaque .btnEdit { background:green; border:none; cursor:pointer; padding:6px; border-radius:6px; }
    .suivi-plaque .btnEdit:hover{ background:darkgreen; transform: translate(0px , -1px); transition: 0.3s ease; }
    .suivi-plaque .btnEdit:active{ transform: translate(0px , 2px); }
    .suivi-plaque .btnEdit img{ width:20px;height:20px; }

    .suivi-plaque__poto{width:0px;height:20px; border:1px solid gray;border-radius:10px;}

    .suivi-conception__head-meta { 
        display:flex; 
        gap:8px; 
        align-items:center; 
        margin-top:6px; 
        min-width:0;
        overflow:hidden;
        }
        .suivi-conception__chip {
        display:inline-block;
        padding:4px 8px;
        border-radius:999px;
        font-size:13px;
        font-weight:600;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
        max-width:100%;
        box-shadow:0 1px 2px rgba(2,6,23,0.03);
        border:1px solid rgba(0,0,0,0.04);
        background: rgba(250,250,250,0.85);
        color: #0b1220;
        }
        .suivi-conception__chip.client { background: rgba(14,165,233,0.07); border-color: rgba(14,165,233,0.12); color:#0369a1; }
        .suivi-conception__chip.product { background: rgba(16,185,129,0.07); border-color: rgba(16,185,129,0.12); color:#065f46; }
        /* small note to keep layout neat on small screens */
        @media (max-width:720px){
        .suivi-conception__title { font-size:15px; max-width:28ch; }
        .suivi-conception__head { min-height:72px; padding:10px; gap:10px; }
        .suivi-conception__chip { font-size:12px; padding:3px 7px; }
        }

    /* entrance */
    .plaque-enter { opacity:0; transform: translateY(8px) scale(.995); transition: opacity .32s ease, transform .32s ease; }
    .plaque-enter.plaque-enter-active { opacity:1; transform: translateY(0) scale(1); }
         @media (max-width:1250px){
         .container-select-plaque{
           height: 50vh !important;
         }
          .em-search-row{
          }
         .plaques{
          font-family: "Nunito", sans-serif !important;
         }
          .suivi-plaque__info { display:flex; gap:5px; align-items:center; flex:1; min-width:0; }
          .suivi-plaque { height: 100px !important;display:flex; align-items:center; justify-content:center;flex-direction:column; padding:2px; border-radius:8px; margin-bottom:8px; cursor:pointer; background:#E6E6E6; border:1px solid rgba(2,6,23,0.04); transition: transform .18s ease, box-shadow .18s ease; }
          .suivi-plaque__actions { height: 50px;display:flex; gap:8px; align-items:center; margin-top:10px; }
          .suivi-plaque__actions .btn{font-size:12px; padding:6px 12px;}
         }
        
    /* responsive tweaks */
    @media (max-width:720px){
      .suivi-plaque__code { width:72px; flex:0 0 72px; font-size:14px; }
      .suivi-plaque__meta { font-size:12px; gap:6px; }
    }
    `;
        const s = document.createElement('style');
        s.id = STYLE_ID;
        s.textContent = css;
        document.head.appendChild(s);
      }

      // helpers
      function esc(s) { return s == null ? '' : String(s); }
      function isImageFile(f) {
        if (!f) return false;
        const ext = (f.extension || '').toString().toLowerCase();
        if (ext) return ['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg', 'bmp', 'tiff'].indexOf(ext) !== -1;
        const mt = (f.mime_type || '').toString().toLowerCase();
        if (mt) return mt.startsWith('image/');
        // fallback by filename
        const fn = (f.filename || '').toString().toLowerCase();
        return /\.(jpe?g|png|webp|gif|svg|bmp|tiff)$/.test(fn);
      }
      function getFileUrl(f) {
        if (!f) return null;
        // storage_path preferred, else filename
        return f.storage_path || f.url || f.filename || null;
      }

      // try a few places to find conception files on the plaque object
      function findConceptionFilesFromPlaque(p) {
        if (!p) return [];
        // p.__raw likely contains raw server object
        const raw = p.__raw || p;
        // candidates:
        // - raw.conception.fichiers
        // - raw.fichiers
        // - raw.conception && raw.conception.fichiers
        try {
          if (raw.conception && Array.isArray(raw.conception.fichiers) && raw.conception.fichiers.length) return raw.conception.fichiers;
          if (Array.isArray(raw.fichiers) && raw.fichiers.length) return raw.fichiers;
          if (raw.fichiers && Array.isArray(raw.fichiers)) return raw.fichiers;
          // sometimes server returns nested 'files' or 'fichiers_conception'
          if (Array.isArray(raw.files) && raw.files.length) return raw.files;
          if (Array.isArray(raw.fichiers_conception) && raw.fichiers_conception.length) return raw.fichiers_conception;
        } catch (e) { }
        return [];
      }

      // choose best image for a group of plaques (a conception)
      function normalizeUrl(url) {
        if (!url) return null;
        try {
          const s = String(url).trim();
          // Le constructeur URL résout correctement les ../ et ./ et respecte les protocoles
          // Utilise window.location.href comme base (résout par rapport à la page courante)
          return new URL(s, window.location.href).href;
        } catch (e) {
          // Fallback robuste si URL échoue (rare)
          try {
            if (/^(https?:)?\/\//i.test(url)) return url;
            if (url.startsWith('/')) return window.location.origin + url;
            return window.location.origin + '/' + String(url).replace(/^\.?\//, '');
          } catch (err) {
            return String(url);
          }
        }
      }

      function pickConceptionImageForGroup(plaques) {
        if (!Array.isArray(plaques) || !plaques.length) return null;

        // 1) check direct p.image or p.conception.image / conception_image
        for (const p of plaques) {
          const cand = p && (p.image || (p.conception && p.conception.image) || p.conception_image);
          if (cand) return normalizeUrl(cand);
        }

        // 2) inspect raw objects and fichier arrays
        for (const p of plaques) {
          const raw = p && p.__raw ? p.__raw : p;
          if (!raw) continue;

          const candidates = (raw.conception && Array.isArray(raw.conception.fichiers) && raw.conception.fichiers) ||
            (Array.isArray(raw.fichiers) && raw.fichiers) ||
            (Array.isArray(raw.files) && raw.files) ||
            (Array.isArray(raw.fichiers_conception) && raw.fichiers_conception) ||
            null;
          if (!candidates) continue;

          // prefer image-like
          let chosen = candidates.find(f => {
            if (!f) return false;
            const mt = (f.mime_type || '').toString().toLowerCase();
            if (mt && mt.startsWith('image/')) return true;
            const ext = (f.extension || '').toString().toLowerCase();
            if (ext && ['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg', 'bmp', 'tiff'].includes(ext)) return true;
            const fn = (f.filename || f.storage_path || '').toString().toLowerCase();
            return /\.(jpe?g|png|webp|gif|svg|bmp|tiff)$/.test(fn);
          });
          if (!chosen) chosen = candidates[0];
          if (chosen) {
            const url = chosen.storage_path || chosen.url || chosen.filename || null;
            if (url) return normalizeUrl(url);
          }
        }
        return null;
      }

      // Resolve status information from plaque object using global STATUS_MAP / STATUS_OPTIONS
      function resolveStatus(p) {
        const raw = (p && (p.status || p.statut || p.etat || p.state)) || '';
        // candidate string or object
        let candidate = '';
        if (raw && typeof raw === 'object') {
          candidate = raw.key || raw.code || raw.label || raw.nom || raw.name || raw.value || '';
        } else {
          candidate = String(raw || '');
        }
        const cleaned = candidate.trim();
        // try direct lookup in STATUS_MAP (keys might contain spaces)
        if (window.STATUS_MAP && typeof window.STATUS_MAP === 'object') {
          const lookupKey = String(cleaned).toLowerCase();
          if (lookupKey && window.STATUS_MAP[lookupKey]) {
            const m = window.STATUS_MAP[lookupKey];
            return { key: lookupKey, label: m.label || cleaned, icon: m.icon || null, color: null };
          }
        }
        // try STATUS_OPTIONS (search by key or label)
        if (Array.isArray(window.STATUS_OPTIONS)) {
          const low = cleaned.toLowerCase();
          // match by key
          let found = window.STATUS_OPTIONS.find(o => String(o.key || '').toLowerCase() === low);
          if (!found) {
            // match by label or sub
            found = window.STATUS_OPTIONS.find(o => (o.label || '').toLowerCase() === low || (o.sub || '').toLowerCase() === low);
          }
          if (found) {
            return { key: found.key, label: found.label || cleaned, icon: found.icon || null, color: found.color || null };
          }
        }
        // fallback: if cleaned contains known hashtags (#hex)
        const hexMatch = String(cleaned).match(/#([0-9a-fA-F]{3,8})/);
        if (hexMatch) {
          return { key: null, label: cleaned, icon: null, color: hexMatch[0] };
        }
        // last fallback: return raw label
        return { key: null, label: cleaned || (p && (p.status || p.statut || p.etat) ? String(p.status || p.statut || p.etat) : '') || '—', icon: null, color: null };
      }

      // main renderer (override)
      // main renderer (override) - version corrigée : extraction robuste client/produit
      function groupedRenderPlaquesWithThumb(plaques) {
        const wrap = document.querySelector('.plaques');
        if (!wrap) return console.warn('[suivi] .plaques introuvable pour renderPlaques');
        wrap.innerHTML = '';

        if (!Array.isArray(plaques) || !plaques.length) {
          wrap.innerHTML = '<div class="plaques-empty" style="padding:18px;color:#64748b">Chargement...</div>';
          wrap.style.display = 'none';
          return;
        }

        // utilitaires pour extraire un label lisible d'un champ/objet
        function getLabel(val) {
          if (val == null) return null;
          if (typeof val === 'string') return val.trim() || null;
          if (typeof val === 'number') return String(val);
          if (Array.isArray(val)) return val.map(getLabel).filter(Boolean).join(', ') || null;
          if (typeof val === 'object') {
            return (val.nom || val.name || val.label || val.title || val.value || val.client_name || val.product_name || '').toString().trim() || null;
          }
          return String(val).trim() || null;
        }

        // tente plusieurs chemins / clés possibles sur l'objet plaque, y compris __raw
        function pickFieldFromPlaque(p, candidates) {
          for (const key of candidates) {
            // support dot notation 'conception.nom'
            let val;
            if (key.indexOf('.') !== -1) {
              try {
                val = key.split('.').reduce((o, k) => (o && o[k] != null) ? o[k] : null, p);
              } catch (e) { val = null; }
            } else {
              val = p[key];
            }
            if (val == null && p && p.__raw) {
              try {
                val = key.split('.').reduce((o, k) => (o && o[k] != null) ? o[k] : null, p.__raw);
              } catch (e) { val = null; }
            }
            const lab = getLabel(val);
            if (lab) return lab;
          }
          return null;
        }

        // champs candidats courants (ajoute si ton API utilise d'autres noms)
        const CLIENT_CANDIDATES = ['client', 'client_nom', 'client_name', 'customer', 'customer_name', 'customer_nom', 'clientLabel', 'client_label', 'clientName'];
        const PRODUCT_CANDIDATES = ['produit', 'product', 'produit_nom', 'produit_name', 'product_name', 'product_nom', 'produitName', 'productLabel', 'name'];

        // grouper par conception (même logique qu'avant)
        const groups = new Map();
        plaques.forEach(p => {
          const key = (p.id_conception || p.nom_conception || p.conception || '___no_conception___') + '::' + (p.nom_conception || p.conception || p.id_conception || 'Sans nom');
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(p);
        });

        const groupsArr = Array.from(groups.entries()).map(([k, arr]) => {
          const parts = k.split('::');
          return { idKey: parts[0], name: parts[1], plaques: arr };
        })
          .filter(g => Array.isArray(g.plaques) && g.plaques.some(p => !p.__placeholder))
          .sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));

        groupsArr.forEach((g) => {
          const box = document.createElement('div');
          box.className = 'suivi-conception';
          box.dataset.conception = esc(g.idKey);

          const head = document.createElement('div');
          head.className = 'suivi-conception__head';

          const left = document.createElement('div');
          left.className = 'suivi-conception__head-left';

          const imgUrl = pickConceptionImageForGroup(g.plaques);
          const thumbDiv = document.createElement('div');
          thumbDiv.className = 'conception-thumb';
          const defaultIcon = (window.DEFAULT_IMG || '../img/icon/papeterie-papiers-empiles.png');

          if (imgUrl) {
            const img = document.createElement('img');
            img.alt = esc(g.name) + ' — image';
            img.src = normalizeUrl(imgUrl);
            function onImgError() { img.removeEventListener('error', onImgError); img.src = defaultIcon; }
            img.addEventListener('error', onImgError);
            thumbDiv.appendChild(img);
          } else {
            const img = document.createElement('img');
            img.src = defaultIcon;
            img.alt = 'icone conception';
            thumbDiv.appendChild(img);
          }

          left.appendChild(thumbDiv);

          const titleWrap = document.createElement('div');
          titleWrap.style.display = 'flex';
          titleWrap.style.flexDirection = 'column';
          titleWrap.style.gap = '6px';
          titleWrap.style.minWidth = '0';

          const title = document.createElement('div');
          title.className = 'suivi-conception__title';
          title.textContent = g.name || 'Conception';

          const count = document.createElement('div');
          count.className = 'suivi-conception__count';
          const realCount = g.plaques.filter(x => !x.__placeholder).length;
          count.textContent = `${realCount} plaque${realCount > 1 ? 's' : ''}`;

          titleWrap.appendChild(title);
          titleWrap.appendChild(count);

          // ------- extraction robuste clients & produits -------
          const extractedClients = g.plaques.map(p => pickFieldFromPlaque(p, CLIENT_CANDIDATES)).filter(Boolean);
          const extractedProducts = g.plaques.map(p => pickFieldFromPlaque(p, PRODUCT_CANDIDATES)).filter(Boolean);

          // unique + ordre stable
          const allClients = Array.from(new Set(extractedClients));
          const allProducts = Array.from(new Set(extractedProducts));

          console.debug('[suivi] groupe:', g.name, 'clients:', allClients, 'produits:', allProducts);

          if (allClients.length || allProducts.length) {
            const metaHead = document.createElement('div');
            metaHead.className = 'suivi-conception__head-meta';

            const maxShown = 3;
            if (allClients.length) {
              const shown = allClients.slice(0, maxShown);
              const clientChip = document.createElement('div');
              clientChip.className = 'suivi-conception__chip client';
              clientChip.textContent = shown.join(', ') + (allClients.length > maxShown ? ` +${allClients.length - maxShown}` : '');
              clientChip.title = allClients.join(', ');
              metaHead.appendChild(clientChip);
            }

            if (allProducts.length) {
              const shownP = allProducts.slice(0, maxShown);
              const prodChip = document.createElement('div');
              prodChip.className = 'suivi-conception__chip product';
              prodChip.textContent = shownP.join(', ') + (allProducts.length > maxShown ? ` +${allProducts.length - maxShown}` : '');
              prodChip.title = allProducts.join(', ');
              metaHead.appendChild(prodChip);
            }

            titleWrap.appendChild(metaHead);
          }
          // -----------------------------------------------------

          left.appendChild(titleWrap);
          head.appendChild(left);

          const chev = document.createElement('div');
          chev.className = 'suivi-conception__chev';
          chev.innerHTML = '&#9660;';
          head.appendChild(chev);

          // --- corps (identique à ton code précédent) ---
          const body = document.createElement('div');
          body.className = 'suivi-conception__body';
          const list = document.createElement('div');
          list.className = 'suivi-plaques-list';

          g.plaques.forEach((p, idx) => {
            if (p.__placeholder) return;
            const row = document.createElement('div');
            row.className = 'suivi-plaque plaque-enter';
            row.tabIndex = 0;
            row.dataset.idPl = esc(p.id_plaque || p.id || '');
            row.dataset.idConception = esc(p.id_conception || '');

            const info = document.createElement('div');
            info.className = 'suivi-plaque__info';

            const code = document.createElement('div');
            code.className = 'suivi-plaque__code';
            code.textContent = esc(p.code || p.numero || p.numero_plaque || '');

            const statusInfo = resolveStatus(p);
            const statusWrap = document.createElement('div');
            statusWrap.className = 'suivi-plaque__status';
            const statusBadge = document.createElement('div');
            statusBadge.className = 'suivi-plaque__status-badge';
            if (statusInfo.icon) {
              const img = document.createElement('img');
              img.className = 'suivi-plaque__status-icon';
              img.src = normalizeUrl(statusInfo.icon);
              img.alt = '';
              img.setAttribute('aria-hidden', 'true');
              statusBadge.appendChild(img);
            } else {
              const dot = document.createElement('div');
              dot.className = 'suivi-plaque__status-dot';
              if (statusInfo.color) dot.style.backgroundColor = statusInfo.color;
              else {
                const map = {
                  'en cours': '#f59e0b',
                  'en impression': '#f59e0b',
                  'en stock': '#10b981',
                  'disponible': '#10b981',
                  'quarantaine': '#ef4444',
                  'indisponible': '#ef4444',
                  'comandees': '#0f1724',
                  'commandées': '#0f1724'
                };
                const keyGuess = (String(statusInfo.label || '').toLowerCase());
                dot.style.backgroundColor = map[keyGuess] || '#94a3b8';
              }
              statusBadge.appendChild(dot);
            }
            const labelSpan = document.createElement('span');
            labelSpan.textContent = statusInfo.label || '—';
            labelSpan.style.fontWeight = '600';
            labelSpan.style.fontSize = '12px';
            statusBadge.appendChild(labelSpan);
            statusWrap.appendChild(statusBadge);

            const poto = document.createElement('span');
            poto.className = 'suivi-plaque__poto';

            const metaDiv = document.createElement('div');
            metaDiv.className = 'suivi-plaque__meta';
            const textParts = [];
            metaDiv.appendChild(poto);

            // show produit on plaque if present (essaie plusieurs sources)
            const plaqueProd = pickFieldFromPlaque(p, PRODUCT_CANDIDATES) || p.produit || p.produit_nom || null;
            if (plaqueProd) textParts.unshift(esc(plaqueProd));
            if (p.machine) textParts.push(esc(typeof p.machine === 'object' ? (p.machine.nom_machine || p.machine.name || '') : p.machine));
            const textSpan = document.createElement('span');
            textSpan.textContent = textParts.join(' • ');

            if (p.couleur) {
              let colorValue = '';
              try {
                if (typeof p.couleur === 'object' && p.couleur !== null) {
                  colorValue = p.couleur.hex || p.couleur.code || p.couleur.value || p.couleur.name || '';
                } else {
                  colorValue = String(p.couleur || '').trim();
                }
                const m = String(colorValue).match(/#([0-9a-fA-F]{3,8})/);
                if (m) colorValue = m[0];
              } catch (e) {
                colorValue = String(p.couleur || '');
              }

              const colorDot = document.createElement('div');
              colorDot.className = 'suivi-plaque__color-dot';
              colorDot.title = esc(p.couleur);
              colorDot.setAttribute('aria-label', 'Couleur: ' + esc(p.couleur));
              colorDot.style.backgroundColor = colorValue || 'transparent';
              metaDiv.appendChild(colorDot);
            }

            metaDiv.appendChild(textSpan);
            info.appendChild(code);
            info.appendChild(metaDiv);
            info.appendChild(statusWrap);

            const actions = document.createElement('div');
            actions.className = 'suivi-plaque__actions';
            const btnEdit = document.createElement('button');
            btnEdit.className = 'btnEdit';
            btnEdit.title = 'Modifier la plaque';
            btnEdit.innerHTML = '<img src="../img/icon/editer.png" alt="édit" style="width:18px;height:18px;opacity:0.85;display:none;">';
            actions.appendChild(btnEdit);

            row.appendChild(info);
            row.appendChild(actions);

            row.addEventListener('click', () => {
              document.querySelectorAll('.suivi-plaque.selected').forEach(n => n.classList.remove('selected'));
              row.classList.add('selected');
              const detail = Object.assign({}, p);
              row.dispatchEvent(new CustomEvent('plaque-selected', { detail }));
              window.dispatchEvent(new CustomEvent('plaque-selected', { detail }));
            });
            row.addEventListener('keydown', (ev) => {
              if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); row.click(); }
            });

            btnEdit.addEventListener('click', (ev) => {
              ev.stopPropagation();
              window.dispatchEvent(new CustomEvent('plaque-edit', { detail: Object.assign({}, p) }));
            });

            setTimeout(() => row.classList.add('plaque-enter-active'), 50 + (idx * 22));
            list.appendChild(row);
          });

          body.appendChild(list);

          head.addEventListener('click', () => {
            const isOpen = box.classList.toggle('open');
            head.setAttribute('aria-expanded', String(isOpen));
            if (isOpen) chev.style.transform = 'rotate(180deg)'; else chev.style.transform = 'rotate(0deg)';
            if (isOpen) {
              const first = box.querySelector('.suivi-plaque');
              if (first) first.focus();
            }
          });

          head.tabIndex = 0;
          head.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); head.click(); }
          });

          box.appendChild(head);
          box.appendChild(body);
          wrap.appendChild(box);
        });

        wrap.style.display = 'block';
      }


      // expose globally (overwrite)
      window.renderPlaques = groupedRenderPlaquesWithThumb;
      console.log('[suivi] renderPlaques updated: affichage image conception & statut activés.');
    })();



    (function () {
      'use strict';

      const PLAQUES = document.querySelector('.plaques');
      if (!PLAQUES) return;
      const FILTER = document.querySelector('.filterblack');
      const SEARCH_BTN = document.getElementById('searchBTN');

      // ensure close button exists
      let CLOSE_BTN = PLAQUES.querySelector('.plaques__close');
      if (!CLOSE_BTN) {
        CLOSE_BTN = document.createElement('button');
        CLOSE_BTN.type = 'button';
        CLOSE_BTN.className = 'plaques__close';
        CLOSE_BTN.setAttribute('aria-label', 'Fermer les résultats');
        CLOSE_BTN.textContent = '✕';
        PLAQUES.insertBefore(CLOSE_BTN, PLAQUES.firstChild);
      }

      let originalParent = null;
      let originalNextSibling = null;
      let lastFocused = null;

      function saveOriginalPlace() {
        if (!originalParent) {
          originalParent = PLAQUES.parentElement;
          originalNextSibling = PLAQUES.nextElementSibling;
        }
      }

      function movePlatesToBody() {
        saveOriginalPlace();
        // append to body so fixed positions reference viewport
        document.body.appendChild(PLAQUES);

        // ensure modal fills viewport (inline styles only, NO changes in your CSS file)
        PLAQUES.style.position = 'fixed';
        PLAQUES.style.inset = '0';
        PLAQUES.style.width = '100%';
        PLAQUES.style.height = '100%';
        PLAQUES.style.maxHeight = '100vh';
        PLAQUES.style.margin = '0';
        PLAQUES.style.boxSizing = 'border-box';
        // show (we rely on CSS transitions if present)
        PLAQUES.classList.add('modal-open');
        PLAQUES.style.display = 'block';
      }

      function restorePlates() {
        // remove inline styles applied by movePlatesToBody
        PLAQUES.style.position = '';
        PLAQUES.style.inset = '';
        PLAQUES.style.width = '';
        PLAQUES.style.height = '';
        PLAQUES.style.maxHeight = '';
        PLAQUES.style.margin = '';
        PLAQUES.style.boxSizing = '';
        PLAQUES.style.display = '';

        // restore into original container
        if (originalParent) {
          if (originalNextSibling && originalNextSibling.parentElement === originalParent) {
            originalParent.insertBefore(PLAQUES, originalNextSibling);
          } else {
            originalParent.appendChild(PLAQUES);
          }
        }
        originalParent = null;
        originalNextSibling = null;
        PLAQUES.classList.remove('modal-open');
      }

      // make close button always visible (inline styles only)
      function styleCloseBtn() {
        CLOSE_BTN.style.position = 'fixed';
        CLOSE_BTN.style.top = 'calc(env(safe-area-inset-top, 12px) + 8px)';
        CLOSE_BTN.style.right = '12px';
        CLOSE_BTN.style.zIndex = '2147483647'; // maximum safe z-index
        // keep visual look but ensure it's clickable/visible
        if (!CLOSE_BTN.style.background) CLOSE_BTN.style.background = 'rgba(255,255,255,0.98)';
        if (!CLOSE_BTN.style.border) CLOSE_BTN.style.border = '1px solid rgba(0,0,0,0.06)';
        CLOSE_BTN.style.padding = CLOSE_BTN.style.padding || '8px 10px';
        CLOSE_BTN.style.borderRadius = CLOSE_BTN.style.borderRadius || '8px';
        CLOSE_BTN.style.cursor = 'pointer';
      }

      function openModalIfMobile() {
        if (window.innerWidth < 900) {
          lastFocused = document.activeElement;
          movePlatesToBody();
          styleCloseBtn();
          if (FILTER) FILTER.classList.add('visible');
          // block body scroll behind modal if you want (we don't change stylesheet)
          // but keep body overflow as-is (your styles might set it). modal itself scrolls.
          CLOSE_BTN.focus();
          document.addEventListener('keydown', onKeyDown);
          document.addEventListener('focus', trapFocus, true);
        } else {
          // desktop: ensure inline view
          restorePlates();
        }
      }

      function closeModal() {
        if (FILTER) FILTER.classList.remove('visible');
        document.removeEventListener('keydown', onKeyDown);
        document.removeEventListener('focus', trapFocus, true);
        restorePlates();
        if (lastFocused && typeof lastFocused.focus === 'function') lastFocused.focus();
      }

      function onKeyDown(e) {
        if (e.key === 'Escape') closeModal();
      }

      function trapFocus(e) {
        if (!PLAQUES.classList.contains('modal-open')) return;
        if (!PLAQUES.contains(e.target)) {
          e.stopPropagation();
          CLOSE_BTN.focus();
        }
      }

      // attach handlers
      CLOSE_BTN.addEventListener('click', closeModal);
      if (FILTER) FILTER.addEventListener('click', () => {
        if (PLAQUES.classList.contains('modal-open')) closeModal();
      });

      if (SEARCH_BTN) {
        SEARCH_BTN.addEventListener('click', function () {
          // if renderPlaques is async, prefer to call openModalIfMobile after renderPlaques completes
          setTimeout(openModalIfMobile, 10);
        });
      }

      // auto open after renderPlaques completes (if you use it)
      const origRender = window.renderPlaques;
      if (typeof origRender === 'function') {
        window.renderPlaques = function (plaques) {
          origRender(plaques);
          // if mobile and we have plaques -> open modal
          if (window.innerWidth < 900) {
            const has = PLAQUES && PLAQUES.querySelector('.suivi-plaque');
            if (has) openModalIfMobile();
          }
        };
      }

      // also handle orientation/resize while modal open
      window.addEventListener('resize', () => {
        // if user rotates to desktop width, restore placement
        if (PLAQUES.classList.contains('modal-open') && window.innerWidth >= 900) {
          restorePlates();
        }
      });

    })();



  </script>


  <!-- BLOQUET 4: Bouton et changement de statut sur les plaques (adapté pour audit backend + rechargement historique) -->
  <script>
    (function () {
      'use strict';

      const STATUS_MAP = {
        'stock': 'en_stock',
        'impression': 'en_impression',
        'indispo': 'en_quarantaine'
      };

      function canonicalToBtnKey(canonical) {
        if (!canonical) return null;
        const s = String(canonical).toLowerCase();
        if (s.indexOf('stock') !== -1) return 'stock';
        if (s.indexOf('impression') !== -1 || s.indexOf('imprim') !== -1 || s.indexOf('cours') !== -1) return 'impression';
        if (s.indexOf('quar') !== -1 || s.indexOf('indis') !== -1) return 'indispo';
        return null;
      }

      function deriveCanonicalFromPlaque(plaque) {
        if (!plaque) return null;
        const cand = String(plaque.statut || plaque.status || plaque.etat || plaque.state || '').trim();
        if (!cand) return null;
        if (cand.indexOf('en_') === 0 || cand.indexOf('en ') === 0) return cand.replace(/\s+/g, '_').toLowerCase();
        if (/stock/i.test(cand)) return 'en_stock';
        if (/impress|impr|cours|impression/i.test(cand)) return 'en_impression';
        if (/quar|quarantine|quarantaine|indisp/i.test(cand)) return 'en_quarantaine';
        return cand.toLowerCase();
      }

      function findPlaqueObjectById(id) {
        if (!id) return null;
        const s = String(id);
        const arrays = [window.PLAQUES_DB, window.PLAQUES_DB_DISPLAY];
        for (const arr of arrays) {
          if (!Array.isArray(arr)) continue;
          for (const p of arr) {
            if (String(p.id_plaque || p.id || p.numero || p.code) === s) return p;
          }
        }
        return { id_plaque: id, id: id };
      }

      // PATCH wrapper -> envoie X-User-Id si disponible; retourne JSON
      async function fallbackPatchPlaqueStatus(plaqueObj, canonicalKey) {
        if (!plaqueObj) throw new Error('plaque manquante');
        const id = plaqueObj.id_plaque || plaqueObj.id;
        if (!id) throw new Error('id manquant');

        const payload = { statut: canonicalKey };

        // try to extract current user id from global variables if present
        const userId = (window.CURRENT_USER_ID || (window.CURRENT_USER && window.CURRENT_USER.id) || null);

        const headers = { 'Content-Type': 'application/json' };
        if (userId) headers['X-User-Id'] = String(userId);

        // --- ADD THIS LINE ---
        if (userId) payload.user = String(userId);

        const res = await fetch('/suivi/plaques/' + encodeURIComponent(id), {
          method: 'PATCH',
          headers,
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => null);
          throw new Error('HTTP ' + res.status + ' ' + (txt || ''));
        }
        const json = await res.json();

        // dispatch global event so other modules can react
        try {
          window.dispatchEvent(new CustomEvent('plaque:updated', { detail: { id: id, updated: json } }));
        } catch (e) { /* ignore */ }

        // if history modal API available, refresh audits for this plaque (best-effort)
        try {
          if (typeof window.historyModalLoadAudits === 'function') {
            // fetch latest audits; don't block UI
            window.historyModalLoadAudits(id).catch(err => console.warn('history load failed', err));
          }
        } catch (e) { /* noop */ }

        return json;
      }

      // applyUpdatedPlaqueToUI (ton code inchangé sauf dispatch)
      function applyUpdatedPlaqueToUI(updated) {
        if (!updated) return;
        if (typeof window.suiviModal !== 'undefined' && typeof window.suiviModal.applyPlaqueUpdateToUI === 'function') {
          try {
            window.suiviModal.applyPlaqueUpdateToUI(updated);
            return;
          } catch (e) {
            console.warn('suiviModal.applyPlaqueUpdateToUI failed, fallback will run', e);
          }
        }

        function pickHumanLabel(obj) {
          if (!obj) return null;
          const candidates = ['statut_label', 'statutLibelle', 'statut_libelle', 'status_label', 'statusLabel', 'label', 'libelle', 'display_name', 'name', 'nom'];
          for (const k of candidates) {
            if (obj[k] != null && String(obj[k]).trim() !== '') return String(obj[k]).trim();
          }
          return null;
        }

        function prettyFromCanonical(canon) {
          if (!canon) return null;
          const s = String(canon).replace(/^en[_\s]+/i, '').replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
          if (!s) return null;
          return s.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        const colorMap = {
          'en cours': '#f59e0b',
          'en impression': '#f59e0b',
          'en stock': '#10b981',
          'disponible': '#10b981',
          'quarantaine': '#ef4444',
          'indisponible': '#ef4444',
          'comandees': '#0f1724',
          'commandées': '#0f1724'
        };

        let humanLabel = pickHumanLabel(updated);
        if (!humanLabel && updated.__raw) humanLabel = pickHumanLabel(updated.__raw);

        const canonical = (updated.statut || updated.status || updated.etat || updated.state || '') + '';
        let labelText = humanLabel || null;
        if (!labelText && canonical) labelText = prettyFromCanonical(canonical) || null;

        const uid = String(updated.id_plaque || updated.id || updated.numero || updated.code || '');
        if (!labelText && uid && Array.isArray(window.PLAQUES_DB)) {
          const existing = window.PLAQUES_DB.find(x => String(x.id_plaque || x.id || x.numero || x.code) === uid);
          if (existing) {
            labelText = pickHumanLabel(existing) || (existing.status || existing.statut || existing.etat || existing.state) || null;
          }
        }
        if (!labelText) labelText = String(canonical || '—');

        let dotColor = null;
        try {
          if (typeof resolveStatus === 'function') {
            const si = resolveStatus(updated);
            if (si && si.color) dotColor = si.color;
            if (!labelText && si && si.label) labelText = si.label;
          }
        } catch (e) { }

        if (!dotColor) {
          const l = String(labelText || '').toLowerCase();
          if (colorMap[l]) dotColor = colorMap[l];
          else if (/stock/i.test(l)) dotColor = '#10b981';
          else if (/impress|imprim|cours/i.test(l)) dotColor = '#f59e0b';
          else if (/quar|quarantine|quarantaine|indisp/i.test(l)) dotColor = '#ef4444';
          else dotColor = '#94a3b8';
        }

        if (uid) {
          const rows = document.querySelectorAll('.suivi-plaque');
          for (const r of rows) {
            const rid = String(r.dataset.idPl || r.dataset.id || r.dataset.idpl || '');
            if (rid !== uid) continue;

            const statusWrap = r.querySelector('.suivi-plaque__status');
            if (statusWrap) {
              statusWrap.innerHTML = '';
              const badge = document.createElement('div');
              badge.className = 'suivi-plaque__status-badge';
              const dot = document.createElement('div');
              dot.className = 'suivi-plaque__status-dot';
              dot.style.backgroundColor = dotColor;
              badge.appendChild(dot);
              const span = document.createElement('span');
              span.textContent = labelText || '—';
              span.style.fontWeight = '600';
              span.style.fontSize = '12px';
              badge.appendChild(span);
              statusWrap.appendChild(badge);
            }

            const group = r.querySelector('.suivi-status-group');
            if (group) {
              let canon = canonical || null;
              if (!canon && typeof deriveCanonicalFromPlaque === 'function') canon = deriveCanonicalFromPlaque(updated);
              let btnKey = null;
              if (canon && typeof canonicalToBtnKey === 'function') btnKey = canonicalToBtnKey(canon);
              if (!btnKey) {
                if (/stock/i.test(labelText)) btnKey = 'stock';
                else if (/impress|imprim|cours/i.test(labelText)) btnKey = 'impression';
                else if (/quar|indis|quaran/i.test(labelText)) btnKey = 'indispo';
              }
              if (btnKey) {
                group.querySelectorAll('button').forEach(b => {
                  if (String(b.dataset.key) === String(btnKey)) {
                    b.classList.add('active');
                    b.setAttribute('aria-pressed', 'true');
                  } else {
                    b.classList.remove('active');
                    b.setAttribute('aria-pressed', 'false');
                  }
                });
              }
            }

            break;
          }
        }

        try {
          const arrays = [window.PLAQUES_DB, window.PLAQUES_DB_DISPLAY];
          for (const arr of arrays) {
            if (!Array.isArray(arr)) continue;
            for (let i = 0; i < arr.length; i++) {
              const item = arr[i];
              if (String(item.id_plaque || item.id || item.numero || item.code) === uid) {
                const merged = Object.assign({}, item, updated);
                const serverHuman = pickHumanLabel(updated) || (updated.__raw && pickHumanLabel(updated.__raw));
                if (!serverHuman) {
                  const prevLabel = pickHumanLabel(item) || (item.status || item.statut || item.etat || null);
                  if (prevLabel) merged._preserved_status_label = prevLabel;
                  if (prevLabel && !merged.status_text) merged.status_text = prevLabel;
                }
                arr[i] = merged;
                break;
              }
            }
          }
        } catch (e) { console.warn('mem update failed', e); }
      }

      function setGroupActiveByKey(groupEl, btnKey) {
        if (!groupEl) return;
        groupEl.querySelectorAll('button').forEach(b => {
          const k = b.dataset.key;
          if (String(k) === String(btnKey)) {
            b.classList.add('active');
            b.setAttribute('aria-pressed', 'true');
          } else {
            b.classList.remove('active');
            b.setAttribute('aria-pressed', 'false');
          }
        });
      }

      function makeStatusButtonGroup(rowId, plaqueObj) {
        const group = document.createElement('div');
        group.className = 'suivi-status-group';

        const bStock = document.createElement('button');
        bStock.type = 'button'; bStock.className = 'btn left stock'; bStock.textContent = 'En stock';
        bStock.dataset.key = 'stock'; bStock.title = 'Mettre en stock'; bStock.setAttribute('aria-pressed', 'false');

        const bImp = document.createElement('button');
        bImp.type = 'button'; bImp.className = 'btn middle impression'; bImp.textContent = 'En impression';
        bImp.dataset.key = 'impression'; bImp.title = 'Mettre en impression'; bImp.setAttribute('aria-pressed', 'false');

        const bInd = document.createElement('button');
        bInd.type = 'button'; bInd.className = 'btn right indispo'; bInd.textContent = 'Indisponible';
        bInd.dataset.key = 'indispo'; bInd.title = 'Mettre en quarantaine (indisponible)'; bInd.setAttribute('aria-pressed', 'false');

        const buttons = [bStock, bImp, bInd];

        const plaque = plaqueObj || findPlaqueObjectById(rowId);
        const derivedCanonical = deriveCanonicalFromPlaque(plaque);
        const initialBtn = canonicalToBtnKey(derivedCanonical);
        if (initialBtn) setTimeout(() => setGroupActiveByKey(group, initialBtn), 10);

        buttons.forEach(btn => {
          btn.addEventListener('mousedown', e => e.stopPropagation());
          btn.addEventListener('click', async (ev) => {
            ev.stopPropagation(); ev.preventDefault();
            const uiKey = btn.dataset.key;
            const canonical = STATUS_MAP[uiKey];
            if (!canonical) { console.warn('status key unknown', uiKey); return; }

            const row = btn.closest('.suivi-plaque');
            const id = row && (row.dataset.idPl || row.dataset.id) ? (row.dataset.idPl || row.dataset.id) : rowId;
            const plaqueObj = findPlaqueObjectById(id);

            buttons.forEach(b => b.disabled = true);

            const patchFn = (window.suiviModal && typeof window.suiviModal.patchPlaqueStatus === 'function')
              ? window.suiviModal.patchPlaqueStatus : fallbackPatchPlaqueStatus;
            try {
              const updated = await patchFn(plaqueObj, canonical);
              applyUpdatedPlaqueToUI(updated);
              const usedCanon = updated.statut || updated.status || updated.etat || canonical;
              const usedKey = canonicalToBtnKey(usedCanon) || uiKey;
              setGroupActiveByKey(group, usedKey);

              // small success pulse
              try { btn.animate([{ transform: 'scale(1.03)' }, { transform: 'scale(0.98)' }, { transform: 'scale(1)' }], { duration: 260 }); } catch (e) { }
            } catch (err) {
              console.error('update failed', err);
              try { btn.animate([{ transform: 'translateX(-6px)' }, { transform: 'translateX(6px)' }, { transform: 'translateX(0)' }], { duration: 220 }); } catch (e) { }
            } finally {
              buttons.forEach(b => b.disabled = false);
            }
          });
        });

        group.appendChild(bStock);
        group.appendChild(bImp);
        group.appendChild(bInd);
        return group;
      }

      function installStatusButtonsForExistingRows() {
        document.querySelectorAll('.suivi-plaque').forEach(row => {
          const actions = row.querySelector('.suivi-plaque__actions');
          if (!actions) return;
          if (actions.querySelector('.suivi-status-group')) {
            const group = actions.querySelector('.suivi-status-group');
            const plaque = findPlaqueObjectById(row.dataset.idPl || row.dataset.id);
            const canon = deriveCanonicalFromPlaque(plaque);
            const btnKey = canonicalToBtnKey(canon);
            if (btnKey) setGroupActiveByKey(group, btnKey);
            return;
          }
          actions.querySelectorAll('.btnEdit').forEach(n => n.remove());
          const plaqueObj = findPlaqueObjectById(row.dataset.idPl || row.dataset.id);
          const group = makeStatusButtonGroup(row.dataset.idPl || row.dataset.id, plaqueObj);
          actions.appendChild(group);
        });
      }

      const plaquesWrap = document.querySelector('.plaques');
      if (plaquesWrap) {
        const mo = new MutationObserver(muts => {
          for (const m of muts) {
            if (!m.addedNodes) continue;
            m.addedNodes.forEach(n => {
              if (!(n instanceof HTMLElement)) return;
              if (n.matches && (n.matches('.suivi-plaque') || n.matches('.plaque') || n.matches('.suivi-conception'))) {
                setTimeout(installStatusButtonsForExistingRows, 40);
              } else if (n.querySelector) {
                setTimeout(installStatusButtonsForExistingRows, 60);
              }
            });
          }
        });
        mo.observe(plaquesWrap, { childList: true, subtree: true });
      }

      setTimeout(installStatusButtonsForExistingRows, 120);

      // expose helper
      window.installSuiviStatusButtons = installStatusButtonsForExistingRows;

    })();
  </script>

  <!-- BLOQUET 5: Modal Historique -->
  <!-- BLOQUET 5: Modal Historique -->
  <script>
    /* Historique — modal + sidebar filtres (version robuste, responsive, focus-trap)
       Remarques : ce script charge par défaut les derniers audits globaux si ouvert sans plaqueId.
    */
    (function () {
      'use strict';

      // -------------------------
      // CSS (injecte seulement si absent)
      // -------------------------
      if (!document.getElementById('history-modal-styles')) {
        const css = `
/* (le même CSS que vous aviez; inchangé pour préserver le style) */
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap');
#historyModalOverlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 2147483640; background: rgba(2,6,23,0.45); padding: 20px; }
.history-modal { width: min(1100px, 98vw); max-height: 92vh; overflow: hidden; border-radius: 12px; background: linear-gradient(180deg,#ffffff,#f8fbff); box-shadow: 0 18px 40px rgba(2,6,23,0.18); display: flex; flex-direction: column; font-family: 'Nunito', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
.history-modal * { font-family: inherit; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
.history-modal header { padding: 14px 16px; display:flex; gap:12px; align-items: center; justify-content: space-between; border-bottom: 1px solid rgba(2,6,23,0.04); }
.history-modal .title { display:flex; gap:12px; align-items:center; }
.history-modal h3 { margin:0; font-size:18px; color:#081226; font-weight:700; }
.history-modal p.sub { margin:0; font-size:13px; color:#475569; opacity:0.95; }
.history-modal .toolbar-right { display:flex; gap:8px; align-items:center; }
.history-modal .close-btn, .history-modal .filters-toggle { background:transparent; border:none; font-size:16px; cursor:pointer; padding:8px; border-radius:8px; color:#0b1220; }
.history-modal .filters-toggle { border:1px solid rgba(2,6,23,0.06); padding:6px 10px; background:#fff; }
.history-modal .filters-toggle:hover, .history-modal .close-btn:hover { box-shadow: 0 6px 18px rgba(2,6,23,0.04); }

.history-modal .panel-body { padding: 12px; overflow:hidden; display:flex; gap:14px; min-height:360px; }
.history-filters { min-width: 300px; max-width: 320px; flex: 0 0 320px; background: #fff; border-radius: 10px; padding: 12px; box-shadow: 0 6px 18px rgba(2,6,23,0.04); border: 1px solid rgba(2,6,23,0.03); position:relative; transition: all 180ms ease; }
.history-filters .collapse-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px; }
.history-filters .filters-icon { display:none; font-size:13px; color:#64748b; text-align:center; padding:10px 0; }
.history-filters.collapsed { width:56px; min-width:56px; max-width:56px; padding:10px 8px; }
.history-filters.collapsed h4, .history-filters.collapsed .field, .history-filters.collapsed .actions { display:none; }
.history-filters.collapsed .filters-icon { display:block; }

.history-filters .filters-close-mobile { display:none; border:none; background:transparent; color:#0b1220; padding:6px; border-radius:8px; }
.history-filters h4 { margin:0 0 10px 0; font-size:14px; color:#0b1220; font-weight:700; }
.history-filters .field { margin-bottom:10px; }
.history-filters label { display:block; font-size:12px; color:#334155; margin-bottom:6px; font-weight:600; }
.history-filters input[type="text"], .history-filters select, .history-filters input[type="date"] { width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(3,10,30,0.06); font-size:13px; background:transparent; box-sizing:border-box; }
.history-filters .actions { display:flex; gap:8px; margin-top:8px; justify-content:space-between; }
.history-filters .btn { padding:8px 10px; border-radius:8px; border:1px solid rgba(2,6,23,0.06); background:transparent; cursor:pointer; font-weight:600; }
.history-filters .btn.primary { background:#0b6efd; color:#fff; border-color:transparent; }

.history-list-wrap { flex:1 1 auto; display:flex; flex-direction:column; gap:12px; min-width:0; }
.history-toolbar { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:0 6px; }
.history-count { color:#475569; font-size:13px; }
.history-list { overflow:auto; padding:8px; border-radius:10px; background:linear-gradient(180deg,#fbfdff,#ffffff); border:1px solid rgba(2,6,23,0.03); flex:1 1 auto; min-height:140px; }

.history-entry { display:block; padding:14px; margin-bottom:10px; border-radius:10px; background: #fff; box-shadow: 0 8px 20px rgba(2,6,23,0.05); border:1px solid rgba(2,6,23,0.03); transition: transform 160ms ease, box-shadow 160ms ease; position:relative; }
.history-entry:hover { transform: translateY(-4px); box-shadow: 0 20px 40px rgba(2,6,23,0.08); }
.history-entry .main { display:flex; align-items:flex-start; gap:12px; }
.history-entry .pin { width:12px; height:12px; border-radius:50%; flex:0 0 12px; margin-top:6px; }
.history-entry .text { flex:1; min-width:0; }
.history-entry .text .line1 { font-size:15px; color:#081226; font-weight:800; margin-bottom:6px; line-height:1.25; }
.history-entry .text .line2 { font-size:13px; color:#475569; margin-bottom:8px; }
.history-entry .meta { font-size:12px; color:#64748b; }

.history-entry { border-left: 6px solid transparent; }

.empty-state { padding:28px; text-align:center; color:#64748b; }
.history-footer { display:flex; gap:8px; justify-content:flex-end; padding:10px 14px; border-top:1px solid rgba(2,6,23,0.04); }
.page-btn { padding:8px 10px; border-radius:8px; background:transparent; border:1px solid rgba(2,6,23,0.06); cursor:pointer; }

@media (max-width:900px) {
  .history-modal { width: 96vw; max-height: 94vh; }
  .history-filters { display:none; position:relative; }
  #historyModalOverlay.filters-open .history-filters {
    display:block;
    position: absolute;
    top: 72px;
    left: 8px;
    right: 8px;
    z-index: 2147483651;
    max-height: calc(80vh - 72px);
    overflow:auto;
    box-shadow: 0 30px 60px rgba(2,6,23,0.16);
  }
  .history-modal .panel-body { padding: 8px; }
  .history-toolbar { padding: 6px; gap:8px; }
  .history-count { font-size:12px; }
  .history-entry .text .line1 { font-size:14px; }
  .history-entry .meta { font-size:11px; }
  .history-filters .filters-close-mobile { display:inline-block; }
}
`;
        const st = document.createElement('style');
        st.id = 'history-modal-styles';
        st.textContent = css;
        document.head.appendChild(st);
      }

      // -------------------------
      // Utilities
      // -------------------------
      const debounce = (fn, t = 120) => { let id; return (...a) => { clearTimeout(id); id = setTimeout(() => fn(...a), t); }; };
      const escapeHtml = (s = '') => String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));

      // Prevent double init (SPA friendly)
      if (window.__historyModalInit) return;
      window.__historyModalInit = true;

      // -------------------------
      // Build DOM (idempotent)
      // -------------------------
      function createModalDOM() {
        if (document.getElementById('historyModalOverlay')) return;
        const overlay = document.createElement('div');
        overlay.id = 'historyModalOverlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-hidden', 'true');
        overlay.style.display = 'none';

        const modal = document.createElement('div');
        modal.className = 'history-modal';
        modal.tabIndex = -1;

        modal.innerHTML = `
      <header>
        <div class="title">
          <img src="../img/icon/devis.png" alt="" style="width:36px;height:36px;object-fit:contain;">
          <div>
            <h3>Historique des statuts</h3>
            <p class="sub">Toutes les actions sur les plaques — filtrez par plaque, utilisateur, statut ou date</p>
          </div>
        </div>
        <div class="toolbar-right">
          <button id="historyToggleFilters" class="filters-toggle" aria-expanded="false" aria-controls="histFilters">Filtres</button>
          <button class="close-btn" id="historyCloseBtn" aria-label="Fermer">✕</button>
        </div>
      </header>

      <div class="panel-body">
        <aside id="histFilters" class="history-filters" aria-hidden="false">
          <div class="collapse-row">
            <button id="histFiltersCollapse" class="btn" title="Réduire/Afficher" style="margin-bottom: 10px;">≡</button>
            <button id="histFiltersCloseMobile" class="filters-close-mobile" title="Fermer">Fermer</button>
          </div>
          <h4>Filtres</h4>
          <div class="field"><label for="histFilterPlaque">N° Plaque</label><input type="text" id="histFilterPlaque" placeholder="Ex: 6523"></div>
          <div class="field"><label for="histFilterUser">Utilisateur</label><input type="text" id="histFilterUser" placeholder="Nom utilisateur"></div>
          <div class="field"><label for="histFilterStatus">Statut</label><select id="histFilterStatus"><option value="">-- Tous les statuts --</option></select></div>
          <div style="display:flex;gap:8px;">
            <div style="flex:1" class="field"><label for="histFilterFrom">Date (de)</label><input type="date" id="histFilterFrom"></div>
            <div style="flex:1" class="field"><label for="histFilterTo">Date (à)</label><input type="date" id="histFilterTo"></div>
          </div>
          <div class="actions">
            <button id="histClearBtn" class="btn">Vider</button>
            <button id="histApplyBtn" class="btn primary">Appliquer</button>
          </div>
        </aside>

        <section class="history-list-wrap" aria-live="polite">
          <div class="history-toolbar">
            <div class="history-count" id="historyCount">0 résultats</div>
            <div style="display:flex;gap:8px;align-items:center;">
              <input id="histQuickSearch" type="text" placeholder="Recherche rapide (texte libre)" style="padding:8px 10px;border-radius:8px;border:1px solid rgba(2,6,23,0.06);">
            </div>
          </div>

          <div class="history-list" id="historyList" tabindex="0"></div>

          <div class="history-footer">
            <button class="page-btn" id="historyPrev">← Préc.</button>
            <button class="page-btn" id="historyNext">Suiv. →</button>
          </div>
        </section>
      </div>
    `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);
      }

      createModalDOM();

      // -------------------------
      // Element refs (safe)
      // -------------------------
      const overlayEl = document.getElementById('historyModalOverlay');
      const modalEl = overlayEl && overlayEl.querySelector('.history-modal');
      if (!overlayEl || !modalEl) return;
      const statusSelect = modalEl.querySelector('#histFilterStatus');
      const listEl = modalEl.querySelector('#historyList');
      const countEl = modalEl.querySelector('#historyCount');

      // -------------------------
      // Status options
      // -------------------------
      const statusOpts = (window.STATUS_OPTIONS && Array.isArray(window.STATUS_OPTIONS)) ? window.STATUS_OPTIONS : [
        { key: 'en_stock', label: 'En stock', color: '#10b981' },
        { key: 'en_impression', label: 'En impression', color: '#f59e0b' },
        { key: 'en_quarantaine', label: 'Quarantaine', color: '#ef4444' },
        { key: 'indisponible', label: 'Indisponible', color: '#374151' }
      ];
      if (statusSelect) {
        statusSelect.innerHTML = '<option value="">-- Tous les statuts --</option>' + statusOpts.map(s => `<option value="${s.key}" data-color="${s.color || ''}">${escapeHtml(s.label)}</option>`).join('');
      }

      // -------------------------
      // State & render helpers
      // -------------------------
      let entries = [];           // start empty -> load from backend
      let filtered = [];
      let page = 0;
      const PAGE_SIZE = 8;

      function statusDefFor(key) {
        if (!key) return null;
        return (window.STATUS_OPTIONS || statusOpts).find(s => s.key === key) || statusOpts.find(s => s.key === key) || { key, label: key || '—', color: '#999' };
      }

      function fmtDate(iso) {
        try { return new Date(iso).toLocaleString(); } catch (e) { return iso || ''; }
      }

      function renderEntry(e) {
        const def = statusDefFor(e.statusKey) || { label: e.statusLabel || '—', color: e.statusColor || '#999' };
        const pinColor = def.color || e.statusColor || '#999';
        const entry = document.createElement('article');
        entry.className = 'history-entry';
        entry.style.borderLeft = '6px solid ' + pinColor;

        // Get user display name - handle both object and string formats
        // ...inside renderEntry(e)...
        let userDisplay = '—';
        if (e.user) {
          if (typeof e.user === 'object') {
            userDisplay =
              e.user.nom_complet && e.user.nom_complet.trim() ? e.user.nom_complet :
                e.user.display_name && e.user.display_name.trim() ? e.user.display_name :
                  e.user.username && e.user.username.trim() ? e.user.username :
                    e.user.id ? e.user.id : '—';
          } else {
            userDisplay = e.user;
          }
        }

        entry.innerHTML = `
  <div class="main">
    <div class="pin" title="${escapeHtml(def.label)}" style="background:${pinColor};"></div>
    <div class="text">
      <div class="line1">La plaque N° ${escapeHtml(String(e.plaque || '—'))} — <span style="font-weight:800;color:${pinColor}">${escapeHtml(def.label)}</span></div>
      <div class="line2">${escapeHtml(e.note || '')}</div>
      <div class="meta">Par <strong>${escapeHtml(userDisplay)}</strong> — ${escapeHtml(fmtDate(e.date || ''))}</div>
    </div>
  </div>
`;
        return entry;
      }

      function renderPage() {
        if (!listEl) return;
        listEl.innerHTML = '';
        const start = page * PAGE_SIZE;
        const pageItems = filtered.slice(start, start + PAGE_SIZE);
        if (!pageItems.length) {
          const empty = document.createElement('div');
          empty.className = 'empty-state';
          empty.innerHTML = `<div>Aucun historique trouvé</div>`;
          listEl.appendChild(empty);
        } else {
          pageItems.forEach(it => listEl.appendChild(renderEntry(it)));
        }
        if (countEl) countEl.textContent = `${filtered.length} résultat${filtered.length > 1 ? 's' : ''}`;
        const prevBtn = modalEl.querySelector('#historyPrev');
        const nextBtn = modalEl.querySelector('#historyNext');
        if (prevBtn) prevBtn.disabled = page === 0;
        if (nextBtn) nextBtn.disabled = start + PAGE_SIZE >= filtered.length;
      }

      // -------------------------
      // Filters logic
      // -------------------------
      const inpPlaque = modalEl.querySelector('#histFilterPlaque');
      const inpUser = modalEl.querySelector('#histFilterUser');
      const inpStatus = modalEl.querySelector('#histFilterStatus');
      const inpFrom = modalEl.querySelector('#histFilterFrom');
      const inpTo = modalEl.querySelector('#histFilterTo');
      const btnClear = modalEl.querySelector('#histClearBtn');
      const btnApply = modalEl.querySelector('#histApplyBtn');
      const quickSearch = modalEl.querySelector('#histQuickSearch');

      function applyFilters() {
        const qPlaque = (inpPlaque && inpPlaque.value || '').trim().toLowerCase();
        const qUser = (inpUser && inpUser.value || '').trim().toLowerCase();
        const qStatus = (inpStatus && inpStatus.value || '').trim();
        const qFrom = inpFrom && inpFrom.value ? new Date(inpFrom.value) : null;
        const qTo = inpTo && inpTo.value ? new Date(inpTo.value) : null;
        const qQuick = (quickSearch && quickSearch.value || '').trim().toLowerCase();

        filtered = entries.filter(e => {
          if (qPlaque && !String(e.plaque || '').toLowerCase().includes(qPlaque)) return false;
          if (qUser && !String(e.user || '').toLowerCase().includes(qUser)) return false;
          if (qStatus && String(e.statusKey || '').toLowerCase() !== String(qStatus || '').toLowerCase()) return false;
          if (qFrom) {
            const d = new Date(e.date); if (isNaN(d)) return false;
            if (d < qFrom) return false;
          }
          if (qTo) {
            const d = new Date(e.date); if (isNaN(d)) return false;
            const toEnd = new Date(qTo); toEnd.setHours(23, 59, 59, 999);
            if (d > toEnd) return false;
          }
          if (qQuick) {
            const hay = (String(e.plaque || '') + ' ' + String(e.conception || '') + ' ' + String(e.user || '') + ' ' + String(e.statusLabel || '') + ' ' + (e.note || '')).toLowerCase();
            if (!hay.includes(qQuick)) return false;
          }
          return true;
        });

        page = 0;
        renderPage();
      }

      if (btnApply) btnApply.addEventListener('click', applyFilters);
      if (btnClear) btnClear.addEventListener('click', () => {
        if (inpPlaque) inpPlaque.value = '';
        if (inpUser) inpUser.value = '';
        if (inpStatus) inpStatus.value = '';
        if (inpFrom) inpFrom.value = '';
        if (inpTo) inpTo.value = '';
        if (quickSearch) quickSearch.value = '';
        applyFilters();
      });
      if (quickSearch) quickSearch.addEventListener('input', debounce(() => applyFilters(), 160));

      const prevBtn = modalEl.querySelector('#historyPrev');
      const nextBtn = modalEl.querySelector('#historyNext');
      if (prevBtn) prevBtn.addEventListener('click', () => { if (page === 0) return; page--; renderPage(); });
      if (nextBtn) nextBtn.addEventListener('click', () => { if ((page + 1) * PAGE_SIZE >= filtered.length) return; page++; renderPage(); });

      // -------------------------
      // Open / close + toggle filters behaviour (robuste)
      // -------------------------
      const closeBtn = modalEl.querySelector('#historyCloseBtn');
      const toggleFiltersBtn = modalEl.querySelector('#historyToggleFilters');
      const filtersAside = modalEl.querySelector('#histFilters');
      const collapseBtn = modalEl.querySelector('#histFiltersCollapse');
      const closeMobileBtn = modalEl.querySelector('#histFiltersCloseMobile');

      let lastFocused = null;
      let isOpen = false;

      function lockBodyScroll() { document.documentElement.style.overflow = 'hidden'; document.body.style.overflow = 'hidden'; }
      function unlockBodyScroll() { document.documentElement.style.overflow = ''; document.body.style.overflow = ''; }

      function trapTabKey(e) {
        if (e.key !== 'Tab') return;
        const focusable = modalEl.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])');
        if (!focusable.length) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (e.shiftKey) { if (document.activeElement === first) { e.preventDefault(); last.focus(); } }
        else { if (document.activeElement === last) { e.preventDefault(); first.focus(); } }
      }

      function openModal(openFilters = false) {
        if (isOpen) {
          if (openFilters) {
            overlayEl.classList.add('filters-open');
            overlayEl.setAttribute('data-filters-open', '1');
            if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'true');
            if (filtersAside) filtersAside.classList.remove('collapsed');
            setTimeout(() => { if (filtersAside && typeof filtersAside.scrollIntoView === 'function') filtersAside.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 120);
          }
          return;
        }
        lastFocused = document.activeElement;
        overlayEl.style.display = 'flex';
        overlayEl.setAttribute('aria-hidden', 'false');
        lockBodyScroll();
        overlayEl.classList.remove('filters-open');
        overlayEl.removeAttribute('data-filters-open');
        if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'false');
        if (openFilters) {
          overlayEl.classList.add('filters-open');
          overlayEl.setAttribute('data-filters-open', '1');
          if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'true');
          if (filtersAside) filtersAside.classList.remove('collapsed');
        }
        if (window.innerWidth >= 900 && filtersAside) filtersAside.classList.remove('collapsed');

        // If entries empty, load recent audits globally (default behavior)
        if ((!entries || entries.length === 0)) {
          loadRecentAudits().catch(e => {
            // network errors handled quietly; still render (will show empty)
            console.debug('loadRecentAudits failed', e);
          });
        } else {
          applyFilters();
          renderPage();
        }

        isOpen = true;
        try { modalEl.focus(); } catch (e) { }
        document.addEventListener('keydown', onKeyDown);
      }

      function closeModal() {
        if (!isOpen) return;
        overlayEl.style.display = 'none';
        overlayEl.setAttribute('aria-hidden', 'true');
        unlockBodyScroll();
        overlayEl.classList.remove('filters-open');
        overlayEl.removeAttribute('data-filters-open');
        if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'false');
        isOpen = false;
        document.removeEventListener('keydown', onKeyDown);
        try { if (lastFocused && lastFocused.focus) lastFocused.focus(); } catch (e) { }
      }

      function onKeyDown(e) { if (e.key === 'Escape') { e.preventDefault(); closeModal(); return; } trapTabKey(e); }

      overlayEl.addEventListener('click', (ev) => { if (ev.target === overlayEl) closeModal(); });
      if (closeBtn) closeBtn.addEventListener('click', closeModal);

      if (toggleFiltersBtn) toggleFiltersBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        if (!isOpen) { openModal(true); return; }
        if (window.innerWidth < 900) {
          const now = overlayEl.classList.toggle('filters-open');
          if (now) {
            overlayEl.setAttribute('data-filters-open', '1');
            toggleFiltersBtn.setAttribute('aria-expanded', 'true');
            if (filtersAside) filtersAside.classList.remove('collapsed');
            setTimeout(() => { if (filtersAside && typeof filtersAside.scrollIntoView === 'function') filtersAside.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 120);
          } else {
            overlayEl.removeAttribute('data-filters-open');
            toggleFiltersBtn.setAttribute('aria-expanded', 'false');
          }
        } else {
          if (filtersAside) {
            const collapsed = filtersAside.classList.toggle('collapsed');
            toggleFiltersBtn.setAttribute('aria-expanded', String(!collapsed));
          }
        }
      });

      if (collapseBtn) collapseBtn.addEventListener('click', () => {
        if (!filtersAside) return;
        const collapsed = filtersAside.classList.toggle('collapsed');
        if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', String(!collapsed));
      });

      if (closeMobileBtn) closeMobileBtn.addEventListener('click', () => {
        overlayEl.classList.remove('filters-open');
        overlayEl.removeAttribute('data-filters-open');
        if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'false');
      });

      function refreshToggleVisibility() {
        if (!document.body.contains(modalEl)) { if (toggleFiltersBtn) toggleFiltersBtn.disabled = true; return; }
        if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', String(isOpen && overlayEl.classList.contains('filters-open')));
      }

      const onResize = debounce(() => {
        if (!isOpen) {
          overlayEl.classList.remove('filters-open');
          overlayEl.removeAttribute('data-filters-open');
          if (filtersAside) filtersAside.classList.remove('collapsed');
          if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'false');
          return;
        }
        if (window.innerWidth >= 900) {
          overlayEl.classList.remove('filters-open');
          overlayEl.removeAttribute('data-filters-open');
          if (filtersAside) filtersAside.classList.remove('collapsed');
          if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', 'true');
        } else {
          if (filtersAside) filtersAside.classList.remove('collapsed');
          if (toggleFiltersBtn) toggleFiltersBtn.setAttribute('aria-expanded', String(overlayEl.classList.contains('filters-open')));
        }
      }, 120);
      window.addEventListener('resize', onResize);

      // attach page triggers (buttons that open modal)
      const triggers = Array.from(document.querySelectorAll('#openHistorique, [data-open-historique]'));
      triggers.forEach(t => {
        if (!t.__histBound) {
          t.addEventListener('click', (ev) => {
            ev.preventDefault();
            const plaqueId = t.getAttribute('data-open-historique') || t.getAttribute('data-plaque') || t.dataset.plaque;
            if (plaqueId) {
              window.openHistoryForPlaque && window.openHistoryForPlaque(plaqueId);
            } else {
              openModal();
            }
          });
          t.__histBound = true;
        }
      });

      // -----------------------------------------
      // Backend fetch + mapping helpers
      // -----------------------------------------
      async function fetchAuditsForPlaque(plaqueId, { limit = 200, offset = 0 } = {}) {
        if (!plaqueId) return [];
        const url = `/suivi/plaques/${encodeURIComponent(plaqueId)}/audits?limit=${encodeURIComponent(limit)}&offset=${encodeURIComponent(offset)}`;
        const res = await fetch(url, { method: 'GET', credentials: 'same-origin', headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
          const t = await res.text().catch(() => null);
          throw new Error('HTTP ' + res.status + ' ' + (t || ''));
        }
        return res.json();
      }

      async function fetchRecentAudits({ limit = 200, offset = 0 } = {}) {
        // Nouvelle route serveur: /suivi/audits  (retourne audits globaux)
        const url = `/suivi/audits?limit=${encodeURIComponent(limit)}&offset=${encodeURIComponent(offset)}`;
        const res = await fetch(url, { method: 'GET', credentials: 'same-origin', headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
          const t = await res.text().catch(() => null);
          throw new Error('HTTP ' + res.status + ' ' + (t || ''));
        }
        return res.json();
      }

      function prettyFromCanonical(canon) {
        if (!canon) return null;
        const s = String(canon || '').replace(/^en[_\s]+/i, '').replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
        if (!s) return null;
        return s.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      }

      // Map AuditOut -> modal entry (robuste : utilise user, meta._actor, user_id)
      function mapAuditToEntry(audit) {
        const meta = audit && audit.meta && typeof audit.meta === 'object' ? audit.meta : {};
        // plaque: prefer friendly numero in meta, else plaque_id
        const plaqueNumber = meta.numero_plaque || audit.plaque_id || (audit.target && String(audit.target).split(':')[1]) || null;

        // statut: prefer meta fields or parse action (old->new)
        let statusKey = meta.nouveau_statut || meta.nouveau || null;
        if (!statusKey && typeof audit.action === 'string') {
          const arrow = audit.action.split('->');
          if (arrow.length >= 2) statusKey = arrow[arrow.length - 1].trim();
          else {
            const colon = audit.action.split(':');
            if (colon.length >= 2) statusKey = colon.slice(-1)[0].trim();
          }
        }
        if (statusKey && statusKey.indexOf(' ') !== -1) statusKey = statusKey.replace(/\s+/g, '_');

        const statusLabel = (statusKey ? (statusDefFor(statusKey) || {}).label : null) || meta.nouveau_statut_label || meta.status_label || audit.action || '';

        const statusColor = (statusDefFor(statusKey) || {}).color || meta.statusColor || null;

        // user: try many fallbacks (joined user obj, meta snapshot, user_id)
        let userDisplay = null;
        try {
          if (audit.user && typeof audit.user === 'object') {
            userDisplay = audit.user.username || audit.user.nom_complet || audit.user.name || null;
          }
          if (!userDisplay && meta && typeof meta === 'object' && meta._actor) {
            const actor = meta._actor;
            userDisplay = actor.nom_complet || ((actor.prenom || actor.nom) ? ((actor.prenom || '') + ' ' + (actor.nom || '')).trim() : actor.username || null);
          }
          if (!userDisplay && audit.username) userDisplay = audit.username;
          if (!userDisplay && audit.user_id) userDisplay = String(audit.user_id);
        } catch (e) { userDisplay = userDisplay || null; }

        const note = meta.note || (audit.target || '') || '';

        return {
          plaque: plaqueNumber,
          conception: meta.nom_conception || null,
          statusKey: statusKey || null,
          statusLabel: statusLabel || null,
          statusColor: statusColor || null,
          user: userDisplay || '—',
          date: audit.timestamp || audit.date || audit.created_at || null,
          note: note || ''
        };
      }

      // -------------------------
      // Public: load audits & inject
      // -------------------------
      async function loadAuditsForPlaque(plaqueId, opts = {}) {
        try {
          const rows = await fetchAuditsForPlaque(plaqueId, opts);
          const arr = Array.isArray(rows) ? rows : [];
          const mapped = arr.map(mapAuditToEntry);
          entries = mapped;
          filtered = entries.slice();
          page = 0;
          // do NOT prefill plaque search input (avoid showing UUID)
          applyFilters();
          renderPage();
          return mapped;
        } catch (err) {
          console.error('loadAuditsForPlaque failed', err);
          throw err;
        }
      }

      async function loadRecentAudits(opts = {}) {
        try {
          const rows = await fetchRecentAudits(opts);
          const arr = Array.isArray(rows) ? rows : [];
          // map puis garder uniquement les entrées liées à une plaque (plaque non vide)
          const mapped = arr.map(mapAuditToEntry).filter(m => {
            // m.plaque contient soit numero_plaque ou plaque_id (UUID) — on filtre les falsy
            return !!(m && (m.plaque || '').toString().trim());
          });

          entries = mapped;
          filtered = entries.slice();
          page = 0;
          applyFilters();
          renderPage();
          return mapped;
        } catch (err) {
          console.error('loadRecentAudits failed', err);
          throw err;
        }
      }

      // Expose small API
      window.historyModalLoadAudits = async function (plaqueId, opts = {}) {
        if (plaqueId) return loadAuditsForPlaque(plaqueId, opts);
        return loadRecentAudits(opts);
      };

      window.openHistoryForPlaque = async function (plaqueId) {
        if (!plaqueId) { openModal(); return; }
        try { await loadAuditsForPlaque(plaqueId, { limit: 200, offset: 0 }); } catch (err) { console.warn('preload failed', err); }
        openModal();
      };

      // react to plaque:updated events
      window.addEventListener('plaque:updated', (ev) => {
        try {
          const id = ev && ev.detail && (ev.detail.id || ev.detail.plaqueId);
          if (!id) return;
          if (isOpen) loadAuditsForPlaque(id).catch(e => console.debug('refresh failed', e));
        } catch (e) { }
      });

      // Expose open/close/toggle
      window.openHistoryModal = function () { openModal(); };
      window.closeHistoryModal = function () { closeModal(); };
      window.toggleHistoryFilters = function () { if (!isOpen) openModal(true); else if (toggleFiltersBtn) toggleFiltersBtn.click(); };

      // initial render (empty)
      applyFilters();
      renderPage();
      refreshToggleVisibility();

      // cleanup guard (SPA)
      const observer = new MutationObserver((mut) => {
        if (!document.body.contains(overlayEl)) {
          window.__historyModalInit = false;
          window.removeEventListener('resize', onResize);
          observer.disconnect();
        }
      });
      observer.observe(document.documentElement || document, { childList: true, subtree: true });

    })();
  </script>




  <script>
    /*
      Affiche uniquement la conception passée en paramètre `conception_id`
      -> Utilise window.renderPlaques (groupedRenderPlaquesWithThumb) si présent,
         sinon fallbackRenderPlaques.
      Coller ce script à la FIN de suiviplaque.html, juste avant </body>.
    */
    (function () {
      'use strict';

      // helper fetch (réutilise la même politique que la page)
      async function safeFetchJSON(url) {
        try {
          const res = await fetch(url, { credentials: 'same-origin' });
          if (!res.ok) {
            console.warn('safeFetchJSON non ok', url, res.status);
            return null;
          }
          return await res.json();
        } catch (err) {
          console.warn('safeFetchJSON failed', url, err);
          return null;
        }
      }

      function getParam(name) {
        try {
          return new URLSearchParams(window.location.search).get(name);
        } catch (e) { return null; }
      }

      const conceptionId = getParam('conception_id') || getParam('id_conception') || getParam('conceptionId');
      if (!conceptionId) return; // rien à faire si pas de param

      async function showConceptionOnly(cid) {
        const wrap = document.querySelector('.plaques');
        if (wrap) {
          // affordance visuelle pendant le chargement
          wrap.innerHTML = '<div class="plaques-empty" style="padding:18px;color:#64748b">Chargement de la conception…</div>';
          wrap.style.display = 'block';
        }

        // appelle l'endpoint existant fourni dans suivi.py
        const url = '/suivi/conceptions/' + encodeURIComponent(cid) + '/plaques';
        const plaques = await safeFetchJSON(url);

        if (!Array.isArray(plaques)) {
          const msg = 'Conception introuvable ou erreur serveur (fetch).';
          console.warn(msg, plaques);
          if (wrap) wrap.innerHTML = `<div class="plaques-empty" style="padding:18px;color:#e11">${msg}</div>`;
          return;
        }

        // Assigner les variables globales utilisées ailleurs (compatibilité)
        window.PLAQUES_DB = window.PLAQUES_DB_DISPLAY = plaques;

        // Si la page a défini renderPlaques (groupedRenderPlaquesWithThumb), l'utiliser
        try {
          if (typeof window.renderPlaques === 'function') {
            window.renderPlaques(plaques);
            // showPlaques may exist to open UI etc.
            if (typeof window.showPlaques === 'function') {
              try { window.showPlaques(); } catch (e) { /* noop */ }
            }
          } else {
            // fallback existant dans le fichier
            if (typeof fallbackRenderPlaques === 'function') {
              fallbackRenderPlaques(plaques);
            } else if (wrap) {
              wrap.innerHTML = '<div class="plaques-empty" style="padding:18px;color:#64748b">Impossibilité d\'afficher la conception (render indisponible).</div>';
            }
          }
        } catch (err) {
          console.error('Erreur lors de renderPlaques/fallbackRenderPlaques', err);
          if (typeof fallbackRenderPlaques === 'function') fallbackRenderPlaques(plaques);
        }

        // met en évidence la conception trouvée (si data-conception est l'id utilisé)
        setTimeout(() => {
          // tenter de localiser et ouvrir la conception ; retry au cas où renderPlaques est asynchrone
          let retries = 0;
          const t = setInterval(() => {
            retries++;
            const sel = document.querySelector(`.suivi-conception[data-conception="${cid}"]`) || document.querySelector('.suivi-conception');
            if (!sel) {
              if (retries > 12) {
                clearInterval(t);
                console.warn('Impossible de trouver la conception dans le DOM après rendu.');
              }
              return;
            }

            try {
              // 1) ouvrir le panneau si besoin (préférer le click sur le header qui déclenche le comportement natif)
              if (!sel.classList.contains('open')) {
                const head = sel.querySelector('.suivi-conception__head');
                if (head && typeof head.click === 'function') {
                  head.click();
                } else {
                  // fallback : ajouter la classe "open" si l'ouverture est gérée par la classe CSS
                  sel.classList.add('open');
                }
              }

              // 2) bring into view + highlight
              sel.scrollIntoView({ behavior: 'smooth', block: 'start' });
              sel.classList.add('suivi-conception--highlight');
              setTimeout(() => sel.classList.remove('suivi-conception--highlight'), 2200);
            } catch (e) {
              console.warn('Erreur lors de l\'ouverture/highlight de la conception', e);
            } finally {
              clearInterval(t);
            }
          }, 180);
        }, 150);
      }

      // Attendre un tout petit peu que tout le reste ait été initialisé (renderPlaques etc.)
      setTimeout(() => {
        showConceptionOnly(conceptionId);
      }, 80);

    })();
  </script>

  <style>
    /* style temporaire pour l'animation de mise en évidence (ajoute dans le même bloc ou dans ton CSS global) */
    .suivi-conception--highlight {
      transition: box-shadow .22s ease, transform .22s ease;
      box-shadow: 0 14px 40px rgba(11, 18, 32, 0.12);
      transform: translateY(-6px);
    }
  </style>

  <!-- Notification script -->
  <script>
    (() => {
      // Récupère un token CSRF si le backend le fournis (meta tag ou cookie "XSRF-TOKEN")
      function getCsrfToken() {
        const meta = document.querySelector('meta[name="csrf-token"]');
        if (meta) return meta.getAttribute('content') || null;
        const name = 'XSRF-TOKEN=';
        const cookie = document.cookie.split('; ').find(c => c.startsWith(name));
        if (cookie) return decodeURIComponent(cookie.substring(name.length));
        return null;
      }

      // sanitize simple pour affichage (retire contrôles non imprimables et <, > pour réduire risque d'injection)
      function safeText(v) {
        if (v === null || v === undefined) return '';
        return String(v).replace(/[\u0000-\u001F\u007F<>]/g, '').trim();
      }

      // wrapper fetch qui ajoute CSRF header s'il existe
      async function fetchWithCsrf(url, opts = {}) {
        opts.credentials = 'include';
        opts.headers = opts.headers || {};
        const token = getCsrfToken();
        if (token) opts.headers['X-CSRF-Token'] = token;
        // Accept default json in many endpoints
        opts.headers['Accept'] = opts.headers['Accept'] || 'application/json';
        return fetch(url, opts);
      }

      document.addEventListener('DOMContentLoaded', () => {
        /* ------------------ Overlay & boutons d'action ------------------ */
        const ROOT_SELECTOR = '.index-start .index-elements';
        const AREA = document.querySelector(ROOT_SELECTOR);
        if (AREA) {
          const buttons = Array.from(AREA.querySelectorAll('button'));
          if (buttons.length) {
            const ANIM_DURATION = 650;
            const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            let overlay = null;
            function ensureOverlay() {
              if (overlay) return overlay;
              overlay = document.createElement('div');
              overlay.className = 'plaques-bg-overlay';
              // apparence neutre sécurisée par défaut
              overlay.style.position = 'fixed';
              overlay.style.inset = '0';
              overlay.style.zIndex = '9998';
              overlay.style.pointerEvents = 'auto';
              overlay.style.transition = 'opacity 0.25s ease';
              overlay.style.backgroundColor = 'rgba(0,0,0,0.85)';
              document.body.appendChild(overlay);
              return overlay;
            }

            function pickBackgroundFromElement(el) {
              try {
                const cs = getComputedStyle(el);
                const bgImage = cs.backgroundImage;
                if (bgImage && bgImage !== 'none' && bgImage.indexOf('gradient') !== -1) return { css: bgImage };
                const bgColor = cs.backgroundColor;
                if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') return { css: bgColor };
                const inline = el.style.background || el.style.backgroundImage || el.style.backgroundColor;
                if (inline) return { css: inline };
              } catch (e) {
                // ignore and fallback
              }
              return null;
            }

            const hrefMap = {
              'plaques': 'Plaque/plaques.html',
              'suivi des plaques': 'Plaque/suiviplaque.html',
              'clients': 'Client/clients.html',
              'produits': 'Produit/produits.html',
              'conceptions': 'Conception/conceptions.html',
              'parametres': 'Parametres/parametres.html',
              'annonces': 'Annonces/annonces.html',
              'scan qr': 'Scan/scan.html',
              'tableau de bord': 'index.html',
              'dashboard': 'index.html',
              'accueil': 'index.html'
            };

            function guessHrefFromText(text) {
              if (!text) return null;
              const t = text.toLowerCase().replace(/\s+/g, ' ').trim();

              // match exact map or substring (existing)
              if (hrefMap[t]) return hrefMap[t];
              for (const key in hrefMap) if (t.includes(key)) return hrefMap[key];

              // token-based fallback: si le label contient à la fois "scan" et "qr"
              const words = t.split(/\s+/);
              if (words.includes('scan') && words.includes('qr')) return hrefMap['scan qr'];

              // autres cas : si contient 'scan' et 'plaque' -> aussi rediriger vers scan
              if (words.includes('scan') && words.includes('plaque')) return hrefMap['scan qr'];

              return null;
            }


            function getTargetHref(btn) {
              const dh = btn.getAttribute('data-href') || btn.getAttribute('data-url') || btn.dataset.href || btn.dataset.url;
              if (dh) return dh;
              const a = btn.querySelector('a[href]');
              if (a) return a.getAttribute('href');
              const text = (btn.textContent || '').trim();
              const guess = guessHrefFromText(text);
              if (guess) return guess;
              return null;
            }

            function showOverlayThenRedirect(btn, href) {
              if (!href) return;
              if (reduceMotion) {
                // navigation directe, same-origin assumed
                window.location.assign(href);
                return;
              }

              const bg = pickBackgroundFromElement(btn) || { css: 'rgba(0,0,0,0.85)' };
              const ov = ensureOverlay();

              try {
                if (bg.css && bg.css.indexOf && bg.css.indexOf('gradient') !== -1) {
                  ov.style.backgroundImage = bg.css;
                  ov.style.backgroundColor = '';
                } else if (bg.css) {
                  ov.style.backgroundImage = 'none';
                  ov.style.backgroundColor = bg.css;
                } else {
                  ov.style.backgroundImage = 'none';
                  ov.style.backgroundColor = 'rgba(0,0,0,0.85)';
                }
              } catch (e) {
                ov.style.backgroundImage = 'none';
                ov.style.backgroundColor = 'rgba(0,0,0,0.85)';
              }

              // bloque interactions
              buttons.forEach(b => b.disabled = true);
              // forcer reflow + afficher
              void ov.offsetWidth;
              ov.classList.add('show');

              setTimeout(() => {
                // redirection (relative URL)
                window.location.assign(href);
              }, ANIM_DURATION);
            }

            // attache handlers
            buttons.forEach(btn => {
              btn.addEventListener('click', (e) => {
                if (btn.hasAttribute('data-no-transition')) return;
                const href = getTargetHref(btn);
                if (!href) return; // laisse comportement par défaut si aucun href trouvé
                e.preventDefault();
                showOverlayThenRedirect(btn, href);
              });
            });

            // ESC pour retirer overlay si présent
            document.addEventListener('keydown', (e) => {
              if (e.key === 'Escape' && overlay && overlay.classList.contains('show')) {
                overlay.classList.remove('show');
                buttons.forEach(b => b.disabled = false);
                setTimeout(() => {
                  if (overlay) { overlay.remove(); overlay = null; }
                }, Math.max(ANIM_DURATION, 200));
              }
            });
          }
        }

        /* ------------------ Sidebar / notifications (UNIFIÉ overlay via classe .visible) ------------------ */
        const burgerBtn = document.querySelector('.header .burger');
        const closeBtn = document.querySelector('.sidebar .close-sidebar');
        const sidebar = document.querySelector('.sidebar');
        const notifBtn = document.querySelector('.notif-user');
        const sidenotifEl = document.querySelector('.sidenotif');
        const filterOverlay = document.querySelector('.filterblack');

        if (!filterOverlay) throw new Error('filterOverlay non trouvé');

        filterOverlay.style.transition = 'opacity 0.3s ease'; // laisse le CSS gérer display/opacité via la classe

        // assure état initial cohérent (on laisse le CSS gérer display via .visible)
        filterOverlay.classList.remove('visible');
        if (sidebar) { sidebar.style.transform = 'translateX(-100%)'; sidebar.style.transition = 'transform 0.3s ease'; }
        if (sidenotifEl) { sidenotifEl.style.transform = 'translateX(100%)'; sidenotifEl.style.transition = 'transform 0.3s ease'; sidenotifEl.addEventListener('click', e => e.stopPropagation()); }

        let sidebarOpen = false, notifOpen = false;

        function showOverlay() {
          filterOverlay.classList.add('visible'); // CSS .filterblack.visible { display:block; opacity:0.8; }
          // ensure it's visible for screen readers/interaction if needed
          filterOverlay.setAttribute('aria-hidden', 'false');
        }
        function hideOverlayIfNeeded() {
          if (!sidebarOpen && !notifOpen) {
            filterOverlay.classList.remove('visible');
            filterOverlay.setAttribute('aria-hidden', 'true');
          }
        }

        // open/close qui gardent la logique existante + overlay via classe
        function openSidebar() {
          if (!sidebar) return;
          sidebar.style.transform = 'translateX(0)';
          sidebarOpen = true;
          showOverlay();
        }
        function closeSidebar() {
          if (!sidebar) return;
          sidebar.style.transform = 'translateX(-100%)';
          sidebarOpen = false;
          hideOverlayIfNeeded();
        }
        function openNotif() {
          if (!sidenotifEl) return;
          sidenotifEl.style.transform = 'translateX(0)';
          notifOpen = true;
          showOverlay();
        }
        function closeNotif() {
          if (!sidenotifEl) return;
          sidenotifEl.style.transform = 'translateX(100%)';
          notifOpen = false;
          hideOverlayIfNeeded();
        }

        // handlers
        if (burgerBtn) burgerBtn.addEventListener('click', (e) => { e.stopPropagation(); openSidebar(); });
        if (closeBtn) closeBtn.addEventListener('click', (e) => { e.stopPropagation(); closeSidebar(); });
        if (filterOverlay) filterOverlay.addEventListener('click', () => { if (sidebarOpen) closeSidebar(); if (notifOpen) closeNotif(); });
        if (notifBtn) notifBtn.addEventListener('click', (e) => { e.stopPropagation(); notifOpen ? closeNotif() : openNotif(); });

        // accessibility: fermer avec Escape
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            if (sidebarOpen) closeSidebar();
            if (notifOpen) closeNotif();
          }
        });

        /* ------------------ Vérification d'authentification & déconnexion ------------------ */
        (async function checkAuthAndBindLogout() {
          try {
            const res = await fetch('/auth/me', {
              method: 'GET',
              credentials: 'include' // Important pour les cookies
            });

            if (!res.ok) {
              window.location.replace('login.html');
              return;
            }

            const userData = await res.json();
            console.log('Utilisateur connecté:', userData);

            // Gestion de la déconnexion
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
              logoutBtn.addEventListener('click', async () => {
                await fetch('/auth/logout', {
                  method: 'POST',
                  credentials: 'include'
                });
                window.location.replace('login.html');
              });
            }
          } catch (err) {
            console.error('Erreur de vérification auth:', err);
            window.location.replace('login.html');
          }
        })();

      }); // DOMContentLoaded
    })();

    document.addEventListener('DOMContentLoaded', function () {
      const notifContainer = document.querySelector('.sidenotif .notif-elements');
      const notifCountEl = document.querySelector('.notif-count');
      const notifBtn = document.querySelector('.notif-user');
      const sidenotifEl = document.querySelector('.sidenotif');
      const API_BASE = ''; // même origine
      const POLL_INTERVAL = 15000; // 15s

      function getCsrfToken() {
        const meta = document.querySelector('meta[name="csrf-token"]');
        if (meta) return meta.getAttribute('content');
        const cookie = document.cookie.split('; ').find(c => c.trim().startsWith('XSRF-TOKEN='));
        if (cookie) return decodeURIComponent(cookie.split('=')[1]);
        return '';
      }

      async function getUserInfo() {
        // if DOM has prefilled data-user-id/role, use it
        try {
          if (sidenotifEl && sidenotifEl.dataset && (sidenotifEl.dataset.userId || sidenotifEl.dataset.role)) {
            return { id: sidenotifEl.dataset.userId || null, role: sidenotifEl.dataset.role || null };
          }
          const r = await fetch('/auth/me', { method: 'GET', credentials: 'include' });
          if (!r.ok) {
            console.warn('/auth/me not OK', r.status);
            return { id: null, role: null };
          }
          const data = await r.json();
          // normalise possible keys
          const id = data.id || data.user_id || data.id_utilisateur || null;
          const role = data.role || (data.employe && data.employe.role) || null;
          console.log('getUserInfo ->', { id, role, raw: data });
          return { id, role };
        } catch (e) {
          console.error('getUserInfo error', e);
          return { id: null, role: null };
        }
      }

      async function fetchNotificationsFor(user) {
        if (!user) user = await getUserInfo();
        if (!user) user = { id: null, role: null };
        const params = [];
        if (user.id) params.push('user_id=' + encodeURIComponent(user.id));
        if (user.role) params.push('role=' + encodeURIComponent(user.role));
        const qs = params.length ? ('?' + params.join('&')) : '';
        const url = `${API_BASE}/notifications${qs}&limit=500`.replace('?&', '?');
        console.log('fetchNotifications url:', url);
        try {
          const res = await fetch(url, { method: 'GET', credentials: 'include', headers: { 'Accept': 'application/json' } });
          if (!res.ok) {
            console.warn('fetchNotifications non OK', res.status);
            const txt = await res.text();
            console.warn('fetch body:', txt);
            return [];
          }
          const data = await res.json();
          const items = Array.isArray(data) ? data : (Array.isArray(data.items) ? data.items : []);
          console.log('fetchNotifications result count', items.length);
          return items;
        } catch (e) {
          console.error('Erreur fetchNotifications', e);
          return [];
        }
      }

      function formatNotificationDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const now = new Date();
        const days = Math.floor((now - date) / (1000 * 60 * 60 * 24));
        if (days === 0) return "Aujourd'hui";
        if (days === 1) return "Hier";
        if (days < 7) return `Il y a ${days} jours`;
        return date.toLocaleDateString('fr-FR');
      }

      function createNotificationHTML(notification) {
        const isRead = !!(notification.lue || notification.read);
        let iconSrc = '../img/icon/info.png';
        const type = notification.type_notif || notification.type;
        if (type === 'ajout_plaque') iconSrc = '../img/icon/info.png';
        if (type === 'renouvellement_plaque') iconSrc = '../img/icon/info.png';

        const id = notification.id_notification || notification.id || '';
        const msg = (notification.message || notification.text || notification.title || 'Nouvelle notification')
          .replace(/</g, '&lt;').replace(/>/g, '&gt;');

        return `
      <div class="notif-card ${isRead ? 'notif-read' : 'notif-unread'}" data-id="${id}"
           data-target-conception="${notification.id_conception || ''}"
           data-type="${type}">
        <div class="notif-card-icon"><img src="${iconSrc}" alt="icon"></div>
        <div class="notif-card-text">
          <p>${msg}</p>
          <small>${formatNotificationDate(notification.date_creation || notification.created_at)}</small>
        </div>
      </div>
    `;
      }

      function renderNotifications(notifications) {
        if (!notifContainer) return;
        if (!notifications || notifications.length === 0) {
          notifContainer.innerHTML = `<div class="notif-empty"><p>Aucune notification</p></div>`;
          if (notifCountEl) { notifCountEl.textContent = '0'; notifCountEl.style.display = 'none'; }
          return;
        }
        const byDate = {};
        (notifications || []).forEach(n => {
          const key = formatNotificationDate(n.date_creation || n.created_at || n.date) || 'Autre';
          (byDate[key] = byDate[key] || []).push(n);
        });
        let html = '';
        Object.keys(byDate).forEach(date => {
          html += `<div class="notif-day"><h3>${date}</h3></div>`;
          byDate[date].forEach(n => html += createNotificationHTML(n));
        });
        notifContainer.innerHTML = html;

        const unread = notifications.filter(n => !(n.lue || n.read)).length;
        if (notifCountEl) {
          notifCountEl.textContent = String(unread);
          notifCountEl.style.display = unread > 0 ? 'inline-block' : 'none';
        }
      }

      async function markAsReadLocal(notificationId, user) {
        if (!notificationId) return false;
        user = user || await getUserInfo();
        const params = [];
        if (user.id) params.push('user_id=' + encodeURIComponent(user.id));
        if (user.role) params.push('role=' + encodeURIComponent(user.role));
        const qs = params.length ? ('?' + params.join('&')) : '';
        const url = `${API_BASE}/notifications/mark_read${qs}`;
        console.log('markAsReadLocal ->', url, 'payload', notificationId);
        try {
          const res = await fetch(url, {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': getCsrfToken() || '' },
            body: JSON.stringify({ id_notification: notificationId })
          });
          if (!res.ok) {
            console.warn('mark_read failed', res.status, await res.text());
            return false;
          }
          console.log('mark_read ok', await res.json());
          return true;
        } catch (e) {
          console.error('markAsReadLocal error', e);
          return false;
        }
      }

      async function markAllRead(user) {
        user = user || await getUserInfo();
        if (!user) { console.warn('markAllRead: no user'); return false; }
        const params = [];
        if (user.id) params.push('user_id=' + encodeURIComponent(user.id));
        if (user.role) params.push('role=' + encodeURIComponent(user.role));
        if (!params.length) { console.warn('markAllRead: no user_id or role'); return false; }
        const url = `${API_BASE}/notifications/mark_all_read?${params.join('&')}`;
        console.log('markAllRead ->', url);
        try {
          const res = await fetch(url, { method: 'POST', credentials: 'include', headers: { 'X-CSRF-Token': getCsrfToken() || '' } });
          if (!res.ok) {
            console.warn('markAllRead non OK', res.status);
            console.warn('body', await res.text());
            return false;
          }
          console.log('markAllRead ok', await res.json());
          return true;
        } catch (e) {
          console.error('Erreur markAllRead', e);
          return false;
        }
      }

      // Delegation click on card
      if (notifContainer) {
        notifContainer.addEventListener('click', async function (e) {
          const card = e.target.closest('.notif-card');
          if (!card) return;
          const id = card.dataset.id;
          // optimistic UI
          card.classList.add('notif-read');
          card.classList.remove('notif-unread');
          if (notifCountEl) {
            const current = parseInt(notifCountEl.textContent || '0', 10);
            const newVal = Math.max(0, current - 1);
            notifCountEl.textContent = String(newVal);
            notifCountEl.style.display = newVal > 0 ? 'inline-block' : 'none';
          }
          const user = await getUserInfo();
          await markAsReadLocal(id, user);
          const idConception = card.dataset.targetConception;
          if (idConception) {
            window.location.href = `/Conception/conception.html?id=${encodeURIComponent(idConception)}`;
            return;
          }
          window.dispatchEvent(new Event('closeNotificationsPanel'));
        });
      }

      if (notifBtn) {
        notifBtn.addEventListener('click', async function (e) {
          const user = await getUserInfo();
          const ok = await markAllRead(user);
          if (ok) {
            document.querySelectorAll('.sidenotif .notif-card').forEach(c => { c.classList.add('notif-read'); c.classList.remove('notif-unread'); });
            if (notifCountEl) { notifCountEl.textContent = '0'; notifCountEl.style.display = 'none'; }
          }
          // reload to catch server state
          setTimeout(loadNotifications, 300);
        });
      }

      async function loadNotifications() {
        const user = await getUserInfo();
        console.log('loadNotifications for', user);
        const arr = await fetchNotificationsFor(user);
        renderNotifications(arr);
      }

      // initial + polling
      loadNotifications();
      setInterval(loadNotifications, POLL_INTERVAL);

      // Expose for debug in console
      window.__notif_debug = {
        loadNotifications,
        fetchNotificationsFor,
        markAllRead,
        markAsReadLocal,
        getUserInfo
      };
      console.log('notification debug helper available at window.__notif_debug');
    });
  </script>

  <script>
    /* Paste this single block just before </body> and remove other modal scripts */
    (function () {
      'use strict';

      const PLAQUES = document.querySelector('.plaques');
      if (!PLAQUES) return;

      const FILTER = document.querySelector('.filterblack') || (function createOverlay() {
        // fallback: create a lightweight overlay if none exists
        const ov = document.createElement('div');
        ov.className = 'filterblack';
        Object.assign(ov.style, {
          position: 'fixed', inset: '0', background: 'rgba(0,0,0,0.8)',
          display: 'none', zIndex: '12000', transition: 'opacity .22s ease'
        });
        document.body.appendChild(ov);
        return ov;
      })();

      // create single close button in body (persistant)
      let CLOSE_BTN = document.getElementById('plaques-js-close');
      if (!CLOSE_BTN) {
        CLOSE_BTN = document.createElement('button');
        CLOSE_BTN.id = 'plaques-js-close';
        CLOSE_BTN.className = 'plaques__close';
        CLOSE_BTN.type = 'button';
        CLOSE_BTN.setAttribute('aria-label', 'Fermer les résultats');
        CLOSE_BTN.textContent = '✕';
        Object.assign(CLOSE_BTN.style, {
          position: 'fixed',
          top: 'calc(env(safe-area-inset-top, 12px) + 8px)',
          right: '12px',
          zIndex: '2147483647',
          background: 'rgba(255,255,255,0.98)',
          border: '1px solid rgba(0,0,0,0.06)',
          padding: '8px 10px',
          borderRadius: '8px',
          cursor: 'pointer',
          boxShadow: '0 6px 18px rgba(2,6,23,0.06)',
          fontSize: '20px',
          lineHeight: '1',
          display: 'none' // shown only when modal open
        });
        document.body.appendChild(CLOSE_BTN);
      }

      // minimal state + cached references
      let isOpen = false;
      let lastFocused = null;
      let originalParent = null;
      let originalNextSibling = null;
      const originalInlineStyle = PLAQUES.getAttribute('style') || '';

      function saveOriginalPlace() {
        if (!originalParent) {
          originalParent = PLAQUES.parentElement;
          originalNextSibling = PLAQUES.nextElementSibling;
        }
      }

      function moveToBody() {
        if (PLAQUES.__moved) return;
        saveOriginalPlace();
        PLAQUES.__moved = true;
        // append to body
        document.body.appendChild(PLAQUES);
        // apply minimal inline styles to anchor to viewport
        PLAQUES.setAttribute('data-prev-style', originalInlineStyle);
        Object.assign(PLAQUES.style, {
          position: 'fixed',
          inset: '0',
          width: '100%',
          height: '100%',
          maxHeight: '100vh',
          margin: '0',
          boxSizing: 'border-box',
          display: 'block'
        });
      }

      function restorePlace() {
        if (!PLAQUES.__moved) return;
        // restore inline style (fast)
        const prev = PLAQUES.getAttribute('data-prev-style');
        if (prev == null || prev === '') PLAQUES.removeAttribute('style');
        else PLAQUES.setAttribute('style', prev);
        PLAQUES.removeAttribute('data-prev-style');

        // restore position in DOM
        if (originalParent) {
          try {
            if (originalNextSibling && originalNextSibling.parentElement === originalParent) {
              originalParent.insertBefore(PLAQUES, originalNextSibling);
            } else {
              originalParent.appendChild(PLAQUES);
            }
          } catch (e) {
            // fallback safe append
            originalParent.appendChild(PLAQUES);
          }
        }
        PLAQUES.__moved = false;
        originalParent = null;
        originalNextSibling = null;
      }

      function showOverlay() {
        FILTER.style.display = 'block';
        // small rAF to allow CSS transition if present
        requestAnimationFrame(() => { FILTER.classList.add('visible'); FILTER.style.opacity = ''; });
      }

      function hideOverlay() {
        FILTER.classList.remove('visible');
        // keep overlay display none after transition (fast fallback)
        setTimeout(() => { if (!FILTER.classList.contains('visible')) FILTER.style.display = 'none'; }, 220);
      }

      function openModal() {
        if (isOpen) return;
        isOpen = true;
        lastFocused = document.activeElement;
        moveToBody();
        // show overlay & modal
        showOverlay();
        // small rAF so CSS transitions can run reliably
        requestAnimationFrame(() => {
          PLAQUES.classList.add('modal-open');
          PLAQUES.setAttribute('aria-hidden', 'false');
          // prevent background scrolling (explicit)
          document.documentElement.style.overflow = 'hidden';
          document.body.style.overflow = 'hidden';
          // show global close button and focus it
          CLOSE_BTN.style.display = '';
          try { CLOSE_BTN.focus(); } catch (e) { }
        });
        // register lightweight handlers
        window.addEventListener('keydown', onKeyDown, { passive: true });
      }

      function closeModal() {
        if (!isOpen) return;
        isOpen = false;
        // hide modal class (triggers CSS close animation)
        PLAQUES.classList.remove('modal-open');
        PLAQUES.setAttribute('aria-hidden', 'true');
        // restore overlay / scroll
        hideOverlay();
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';
        // hide close button (after transition)
        CLOSE_BTN.style.display = 'none';
        // restore DOM position after next paint so any closing transition can run
        requestAnimationFrame(() => {
          restorePlace();
        });
        // restore focus
        try { if (lastFocused && typeof lastFocused.focus === 'function') lastFocused.focus(); } catch (e) { }
        window.removeEventListener('keydown', onKeyDown, { passive: true });
      }

      function onKeyDown(e) {
        if (e.key === 'Escape' && isOpen) closeModal();
      }

      // click handlers (single handlers)
      CLOSE_BTN.addEventListener('click', function (ev) {
        ev.preventDefault();
        closeModal();
      }, { passive: false });

      FILTER.addEventListener('click', function () {
        if (isOpen) closeModal();
      }, { passive: true });

      // hook the search button - open modal on mobile after render (if you use renderPlaques)
      const SEARCH_BTN = document.getElementById('searchBTN');
      if (SEARCH_BTN) {
        SEARCH_BTN.addEventListener('click', function () {
          // if renderPlaques is async: call openModal explicitly after renderPlaques completes.
          // we do a micro-tick to allow any sync DOM changes first.
          requestAnimationFrame(() => {
            if (window.innerWidth < 1250) openModal();
          });
        }, { passive: true });
      }

      // If your app calls window.renderPlaques(plaques), auto-open on mobile when content exists
      if (typeof window.renderPlaques === 'function') {
        const original = window.renderPlaques;
        window.renderPlaques = function (plaques) {
          original.call(this, plaques);
          // quick check for generated rows
          requestAnimationFrame(() => {
            const has = PLAQUES.querySelector('.suivi-plaque');
            if (has && window.innerWidth < 1250) openModal();
          });
        };
      }

      // close modal on resize to desktop to avoid stuck state
      window.addEventListener('resize', function () {
        if (isOpen && window.innerWidth >= 1250) {
          closeModal();
        }
      }, { passive: true });

      // quick init: if .plaques already contains modal-open at load, sync UI
      if (PLAQUES.classList.contains('modal-open') && window.innerWidth < 1250) {
        // small delay to finish page load then open
        requestAnimationFrame(openModal);
      }

    })();
  </script>


</body>

</html>